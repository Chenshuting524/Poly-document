{"./":{"url":"./","title":"About Poly Network","keywords":"","body":"Poly Network Poly Network is the world’s leading cross-chain interoperability protocol for heterogeneous chains, enhancing connections between ledgers by providing interoperability in Web 3.0. Its uniquely designed cross-chain bridge technology executes cross-chain transactions by deploying smart contracts on the source chain and enabling communication between heterogeneous chains, including the more popular public chains, right at the protocol layer. Poly Network has integrated over 18 blockchains, including Ethereum, BNB Chain, Polygon, Avalanche, Fantom, Arbitrum, Optimism, Metis, Boba, OEC, HECO, Neo, Ontology, Zilliqa, Gnosis Chain and etc. We provide Protocol for connecting new chains to the poly cross-chain ecosystem Protocol for registering new cross-chain tokens Protocol for building your bridges Specification for customizing business logic contracts Poly dapps @[Token assets Cross-chain transfer]{https://bridge.poly.network/} resources/asset.svg \"rect\" @[NFT cross-chain transfer]{https://bridge.poly.network/nft} resources/nft.svg \"rect\" @[Token Swap]{https://o3swap.com/} resources/swap.svg \"rect\" Join the Community @[Telegram]{https://t.me/polynetworkgroup} resources/Telegram.png \"rect\" @[Discord]{https://discord.com/invite/y6MuEnq} resources/Discord.png \"rect\" @[Medium]{https://polynetwork.medium.com/} resources/Medium.png \"rect\" @[Github]{https://github.com/polynetwork} resources/GitHub.png \"rect\" @[Twitter]{https://twitter.com/PolyNetwork2} resources/Twitter.png \"rect\" @[Youtube]{https://www.youtube.com/channel/UC4vFRyVgvK7RnlkkLDmp23w/featured} resources/youtube.png \"rect\" Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-21 17:35:11 "},"guideline.html":{"url":"guideline.html","title":"Guidelines for Reading","keywords":"","body":"Guidelines for Reading Similar to any other cross-chain service, the accession to Poly cross-chain ecosystem will vary from section to section depending on your specific needs. Here we presuppose four major goals and provide corresponding tutorials for you to realize your goals. You can either click the quick guide below directly or follow the menu on the left navigation. Add New Chains Please read this section if you want to connect your chain to poly: Connect New Chains Build New Bridges Please read this section if you want to build a bridge using poly bridge sdk: Build New Bridges Import New Assets Please read this section if you want to import assets to the poly cross-chain ecosystem: Import New Assets Customize Business Logic Contracts Please read this section if you want to deploy business contract: Customize Business Logic Contracts Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-24 14:49:07 "},"new_chain/readme.html":{"url":"new_chain/readme.html","title":"Connect New Chains","keywords":"","body":"Connect New Chains to Poly Cross-Chain Ecosystem Poly cross-chain ecosystem provides a platform for interaction, data transfer and token transaction among various chains. This ecosystem is inclusive for any chain. If you want to import a new chain into Poly cross-chain ecosystem, this section will be the most helpful tutorial for you. Before that, in order to help you better understand the necessary procedures, a flow chart is provided here. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-24 17:49:16 "},"new_chain/relay_chain/relay_chain_development.html":{"url":"new_chain/relay_chain/relay_chain_development.html","title":"Develop for Poly Chain","keywords":"","body":"Develop for Poly Chain 1. Requirements Before developing poly chain, you have to be well prepared with the listed three prerequisites. 1.1 Make sure the new chain supports Light Client Verification The block header must contain the following information： Hash of the previous block header Merkle state root hash Necessary information to prove the legitimacy of the block header varying from different consensus mechanisms. [!Note|style:flat|label:Notice] If your chain doesn't support techniques like Simple Payment Verification (SPV) protocol in Bitcoin or Light Ethereum Subprotocol (LES) in Ethereum, please get in touch with the poly team via contact@poly.network or https://discord.com/invite/y6MuEnq for more support. 1.2 Offer the block header structure and verification methods Block header structure Serialization and Deserilization methods Block header verification mehtods 1.3 Offer the merkle tree structure and verification methods Merkle tree structure State root verification methods 2. Development Specifications With the prerequisites mentioned above, you can start developing poly chain following the guideline below from the perspective you need. 2.1 Implement methods of block data verification Block Header Synchronization Methods Method Description SyncGenesisHeader It stores and handles the initial block header so that the subsequent block headers of blocks that contain cross-chain events can be verified and synchronized. This method will only be called once for initializing the new chain. Please refer to the code for more details. SyncBlockHeader It consistently synchronizes block cycle change and cross-chain transaction block headers from the new chain to the poly chain. Please refer to the code for more details. Block Header Synchronization Entrance Method Method Description SyncSideChainGenesisHeader It is the entrance method for synchronizing the genesis block header of the new chain to poly chain and synchronizing the genesis header of the poly chain to ccm contract of the new chain. Please refer to the code for more details. The Key information for this method (submitted by .config): Service provider (endpoint) Url of the new chain Selected genesis block height Essential information for verifying genesis headers may exist in header information already or need to be fetched from block headers from other block height Information required for the new chain block header verification 2.2 Implement methods of cross-chain transaction verification Cross Chain Management Method Description MakeDepositProposal It acts as the entrance of verifyFromTx, verifying, storing and returning MakeTxParam for processing cross-chain steps, and verifies cross-chain transactions and store legitimate transactions to poly chain. Please refer to the code for more details. MakeDepositProposal: Requires: service *native.NativeService //Native Service that carries values of information of cross-chain events Returns: type verifyFromTx struct { TxHash []byte CrossChainId []byte //ChainId of source chain FromContractAddress uint64 //Cross Chain Management Contarct address of source chain ToChainId string //ChainId of target chain ToContractAddress uint64 //Cross Chain Management Contarct address of target chain Method []byte //Unlock or lock Args []byte } Method Description verifyFromTx It prepares block header and deserialized proof for verifyMerkleProof, and decodes the extra data from tx and construct MakeTxParam. Please refer to the code for more details. verifyFromTx: Requires: service *native.NativeService proof []byte //the proof to be serialized and verified extra []byte //the transaction information that will be used for constructing verifyFromTx fromChainID uint64, //ChainId of source chain height uint32, //the block height corresponding to current transaction event sideChain *side_chain_manager.SideChain //source chain information that contains ccm contract address Returns: txParam *scom.MakeTxParam Method Description verifyMerkleProof It verifies the Merkle proof obtained by the relayer generated from the source chain to ensure that all transactions included in this block header have been created and can be seen on the poly chain. Please refer to the code for details. verifyMerkleProof: Requires: blockData *types.Header //the blockheader corresponding to current transaction event proof []byte //the serialized proof Returns: Val []byte //the proof result for checking extra before constructing verifyFromTx Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-24 17:48:00 "},"new_chain/side_chain/contracts.html":{"url":"new_chain/side_chain/contracts.html","title":"Develop for New Chain","keywords":"","body":"Develop for New Chain The development of a new chain mainly involves developing cross-chain modules. Here, cross-chain module works as a set of smart contracts. In some cases, it can also work as a native module of blockchain. To help you develop it, here we offer the examples in Solidity for each main method. You may refer to the full code of these contracts. [!Note|style:flat|label:Notice] If the chain integrated to Poly Network supports EVM, developers could freely use our cross-chain contracts as templates. If not, you may need to develop your own contracts which contains the main features as shown in following guidelines. 1. Introduction to Cross-chain Contracts In this part, we sort the contracts into data contract, logic contract and proxy contract to complete the cross-chain contracts. You could either follow the methods listed below or choose other ways for your project. List of contracts: Cross Chain Manager Contract: On source chain, it creates the cross chain transactions that are transferred to the Poly. On target chain, it verifies the legitimacy of transactions and executes the method on target business logic contract. In the following context, it may be referred to as CCM contract. Cross Chain Data Contract: It serves as a database of cross chain transactions. In the following context, it may be referred to as CCD contract. Cross Chain Manager Proxy Contract: It serves as a proxy of CCM contract. When there is any need to upgrade the CCM contract, it would pause old CCM contract and set new CCM contract to CCD contract. Business Logic Contract: It executes the business logic of cross chain projects. It interacts with users and CCM contract both on source chain and target chain. We also offer the guidelines of developing Business Logic Contract. Interactions between contracts 2. Develop Cross Chain Manager Contracts Now it comes to develop cross-chain contracts. Before actually customizing your CCM, you need to implement the listed four main features. Step1. Implement methods of synchronizing genesis block header This step is meant to implement the methods of synchronizing genesis block header of Poly chain to the Cross Chain Manager contract. Example: /* @notice sync Poly chain genesis block header to smart contrat * @dev this function can only be called once, nextbookkeeper of rawHeader can't be empty * @param rawHeader Poly chain genesis block raw header or raw Header including switching consensus peers info * @return true or false */ function initGenesisBlock(bytes memory rawHeader, bytes memory pubKeyList) whenNotPaused public returns(bool) { // Load Ethereum cross chain data contract IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress); // Make sure the contract has not been initialized before require(eccd.getCurEpochConPubKeyBytes().length == 0, \"EthCrossChainData contract has already been initialized!\"); // Parse header and convit the public keys into nextBookKeeper and compare it with header.nextBookKeeper to verify the validity of signature ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader); (bytes20 nextBookKeeper, address[] memory keepers) = ECCUtils.verifyPubkey(pubKeyList); require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\"); // Record current epoch start height and public keys (by storing them in address format) require(eccd.putCurEpochStartHeight(header.height), \"Save Poly chain current epoch start height to Data contract failed!\"); require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain current epoch book keepers to Data contract failed!\"); // Fire the event emit InitGenesisBlockEvent(header.height, rawHeader); return true; } This method should be called at the very beginning and can only be called once. For the input data rawHeader, the nextbookkeeper can not be empty. Firstly, this function is required to check the public key of the current epoch to make sure that the CCM contract is uninitialized. Then we will parse the raw header to get the header.nextBookKeeper. Comparing it with the nextBookKeeper which is converted from pubKeyList, we could verify the validity of signature. After verifying the signature, we could record current epoch start height and the public keys by storing them in address format. And then emit the event InitGenesisBlockEvent. Step2. Implement methods of changing consensus validator This step is meant to implement the methods of changing Poly Chain consensus validator, which is called as book keeper in the code. Example: /* @notice change Poly chain consensus book keeper * @param rawHeader Poly chain change book keeper block raw header * @param pubKeyList Poly chain consensus nodes public key list * @param sigList Poly chain consensus nodes signature list * @return true or false */ function changeBookKeeper(bytes memory rawHeader, bytes memory pubKeyList, bytes memory sigList) whenNotPaused public returns(bool) { // Load Ethereum cross chain data contract ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader); IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress); // Make sure rawHeader.height is higher than recorded current epoch start height uint64 curEpochStartHeight = eccd.getCurEpochStartHeight(); require(header.height > curEpochStartHeight, \"The height of header is lower than current epoch start height!\"); // Ensure the rawHeader is the key header including info of switching consensus peers by containing non-empty nextBookKeeper field require(header.nextBookkeeper != bytes20(0), \"The nextBookKeeper of header is empty\"); // Verify signature of rawHeader comes from pubKeyList address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes()); uint n = polyChainBKs.length; require(ECCUtils.verifySig(rawHeader, sigList, polyChainBKs, n - (n - 1) / 3), \"Verify signature failed!\"); // Convert pubKeyList into ethereum address format and make sure the compound address from the converted ethereum addresses // equals passed in header.nextBookKeeper (bytes20 nextBookKeeper, address[] memory keepers) = ECCUtils.verifyPubkey(pubKeyList); require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\"); // update current epoch start height of Poly chain and current epoch consensus peers book keepers addresses require(eccd.putCurEpochStartHeight(header.height), \"Save MC LatestHeight to Data contract failed!\"); require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain book keepers bytes to Data contract failed!\"); // Fire the change book keeper event emit ChangeBookKeeperEvent(header.height, rawHeader); return true; } Firstly, you need to make sure the rawHeader.height is higher than recorded current epoch start height. Then you need to ensure that the rawHeader is the key header including info of switching consensus peers by containing non-empty nextBookKeeper field. Analogous to initGenesisBlock(), we also need to parse the raw header to get the header.nextBookKeeper. Comparing it with the nextBookKeeper which is converted from pubKeyList, we could verify the validity of signature. After verifying the signature, we could record current epoch start height and current epoch consensus peers book keepers by storing them in address format. And then emit the event ChangeBookKeeperEvent. Step3. Implement methods of pushing cross-chain transactions to Poly chain This step is meant to implement the methods of pushing the serialized cross-chain transaction information to Poly chain. Example: /* * @param toChainId The target chain id * @param toAddress The address in bytes format to receive same amount of tokens in target chain * @param toContract Target smart contract address in bytes in target block chain * @param txData Transaction data for target chain, include toAssetHash, toAddress, amount * @return true or false */ function crossChain(uint64 toChainId, bytes calldata toContract, bytes calldata method, bytes calldata txData) whenNotPaused external returns (bool) { // Only allow whitelist contract to call require(whiteListFromContract[msg.sender],\"Invalid from contract\"); // Load Ethereum cross chain data contract IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress); // To help differentiate two txs, the ethTxHashIndex is increasing automatically uint256 txHashIndex = eccd.getEthTxHashIndex(); // Convert the uint256 into bytes bytes memory paramTxHash = Utils.uint256ToBytes(txHashIndex); // Construct the makeTxParam, and put the hash info storage, proving tx existence bytes memory rawParam = abi.encodePacked(ZeroCopySink.WriteVarBytes(paramTxHash), ZeroCopySink.WriteVarBytes(abi.encodePacked(sha256(abi.encodePacked(address(this), paramTxHash)))), ZeroCopySink.WriteVarBytes(Utils.addressToBytes(msg.sender)), ZeroCopySink.WriteUint64(toChainId), ZeroCopySink.WriteVarBytes(toContract), ZeroCopySink.WriteVarBytes(method), ZeroCopySink.WriteVarBytes(txData) ); // Must save it in the storage to be included in the proof to be verified. require(eccd.putEthTxHash(keccak256(rawParam)), \"Save ethTxHash by index to Data contract failed!\"); // Fire the cross chain event denoting there is a cross chain request from Ethereum network to other public chains through Poly chain network emit CrossChainEvent(tx.origin, paramTxHash, msg.sender, toChainId, toContract, rawParam); return true; } This method can only be called by the contracts in whitelist. It creates cross chain transactions, invoked by service contracts when a cross chain function is carried out in the logic contract. This method constructs the rawParam, which contains transaction hash, msg.sender, target chain id, business logic contract to be invoked on target chain, the target method to be invoked and the serialized transaction data which has been already constructed in business logic contract. Then put the hash of rawParam into storage, proving the existence of transaction . Step4. Implement methods of verifying & executing Transaction This step is meant to implement the methods of verifying the block header and merkle proof. If passing the verification, the transaction could be executed on target chain. Example: /* * @param proof Poly chain transaction merkle proof * @param rawHeader The header containing crossStateRoot to verify the above tx merkle proof * @param headerProof The header merkle proof used to verify rawHeader * @param curRawHeader Any header in current epoch consensus of Poly chain * @param headerSig The coverted signature veriable for solidity derived from Poly chain consensus nodes' signature * used to verify the validity of curRawHeader * @return true or false */ function verifyHeaderAndExecuteTx(bytes memory proof, bytes memory rawHeader, bytes memory headerProof, bytes memory curRawHeader,bytes memory headerSig) whenNotPaused public returns (bool){ ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader); // Load ehereum cross chain data contract IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress); // Get stored consensus public key bytes of current poly chain epoch and deserialize Poly chain consensus public key bytes to address[] address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes()); uint256 curEpochStartHeight = eccd.getCurEpochStartHeight(); uint n = polyChainBKs.length; if (header.height >= curEpochStartHeight) { // It's enough to verify rawHeader signature require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain header signature failed!\"); } else { // We need to verify the signature of curHeader require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain current epoch header signature failed!\"); // Then use curHeader.StateRoot and headerProof to verify rawHeader.CrossStateRoot ECCUtils.Header memory curHeader = ECCUtils.deserializeHeader(curRawHeader); bytes memory proveValue = ECCUtils.merkleProve(headerProof, curHeader.blockRoot); require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), \"verify header proof failed!\"); } // Through rawHeader.CrossStatesRoot, the toMerkleValue or cross chain msg can be verified and parsed from proof bytes memory toMerkleValueBs = ECCUtils.merkleProve(proof, header.crossStatesRoot); // Parse the toMerkleValue struct and make sure the tx has not been processed, then mark this tx as processed ECCUtils.ToMerkleValue memory toMerkleValue = ECCUtils.deserializeMerkleValue(toMerkleValueBs); require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"the transaction has been executed!\"); require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"Save crosschain tx exist failed!\"); // Ethereum ChainId is 2, we need to check the transaction is for Ethereum network require(toMerkleValue.makeTxParam.toChainId == chainId, \"This Tx is not aiming at this network!\"); // Obtain the target contract, so that Ethereum cross chain manager contract can trigger the executation of cross chain tx on Ethereum side address toContract = Utils.bytesToAddress(toMerkleValue.makeTxParam.toContract); // only invoke PreWhiteListed Contract and method For Now require(whiteListContractMethodMap[toContract][toMerkleValue.makeTxParam.method],\"Invalid to contract or method\"); //TODO: check this part to make sure we commit the next line when doing local net UT test require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \"Execute CrossChain Tx failed!\"); // Fire the cross chain event denoting the executation of cross chain tx is successful, // and this tx is coming from other public chains to current Ethereum network emit VerifyHeaderAndExecuteTxEvent(toMerkleValue.fromChainID, toMerkleValue.makeTxParam.toContract, toMerkleValue.txHash, toMerkleValue.makeTxParam.txHash); return true; } /* * @notice Dynamically invoke the target contract, and trigger executation of cross chain tx on Ethereum side * @param _toContract The target contract that will be invoked by the Ethereum Cross Chain Manager contract * @param _method At which method will be invoked within the target contract * @param _args The parameter that will be passed into the target contract * @param _fromContractAddr From chain smart contract address * @param _fromChainId Indicate from which chain current cross chain tx comes * @return true or false */ function _executeCrossChainTx(address _toContract, bytes memory _method, bytes memory _args, bytes memory _fromContractAddr, uint64 _fromChainId) internal returns (bool){ // Ensure the target contract gonna be invoked is indeed a contract rather than a normal account address require(Utils.isContract(_toContract), \"The passed in address is not a contract!\"); bytes memory returnData; bool success; // The returnData will be bytes32, the last byte must be 01; (success, returnData) = _toContract.call(abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, \"(bytes,bytes,uint64)\"))), abi.encode(_args, _fromContractAddr, _fromChainId))); // Ensure the executation is successful require(success == true, \"EthCrossChain call business contract failed\"); // Ensure the returned value is true require(returnData.length != 0, \"No return value from business contract!\"); (bool res,) = ZeroCopySource.NextBool(returnData, 31); require(res == true, \"EthCrossChain call business contract return is not true\"); return true; } This method should be invoked by relayer. In some cases, users could invoke this method by themselves if they get the valid block information from Poly. This method fetches and processes cross chain transactions, finds the merkle root of a transaction based on the block height (in the block header), and verifies the legitimacy of transaction using the transaction parameters. After verifying Poly chain block header and proof, you still need to check if the parameters toContract and toMerkleValue.makeTxParam.method have been pre listed in whitelists. Then it will invoke the business logic contract deployed on the target chain. Invoking will be processed through the internal method _executeCrossChainTx(): This method is meant to invoke the target contract, and trigger executation of cross chain tx on target chain. Firstly, you need to ensure the target contract gonna be invoked is indeed a contract rather than a normal account address. Then construct a method call on target business logic contract: first you need to encodePacked the _method and the format of input data \"(bytes,bytes,uint64)\". Then it would keccak256 the encoded string, use bytes4 to take the first four bytes of the call data for a function call specifies the function to be called. Parameter _method is from the toMerkleValue, which is parsed from proof. And the input parameters format is restricted as (bytes _args, bytes _fromContractAddr, uint64 _fromChainId). These two parts are encodePacked as a method call. After calling the method, you need to check the return value. Only if the return value is true, will the whole cross chain transaction be executed successfully. To guarantee the safety of CCM contract, we keep whitelists of contract addresses and methods to prevent invalid call. Meanwhile, we also set whiteLister to manage these whitelists of CCM contract. Here is the template of adding whitelist. We highly encourage developers to develop the similar features of authority management in personal projects. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-24 16:01:57 "},"new_chain/relayer/relayer.html":{"url":"new_chain/relayer/relayer.html","title":"Develop for Relayer","keywords":"","body":"Develop for Relayer 1. Development Specifications for Relayer If you have successfully deployed the poly chain and new chain, the next step is to develop a poly relayer in your chain. Poly relayer plays the role to relay cross chains messages and interact with CCM contracts, helping you further join into the cross-chain ecosystem. Two components are required in the implementation: Chain LIstener and Chain Submitter. 1.1 Implement Chain Listener Chain Listener is used to fetch data from the source chain, including block headers, cross chain events emitted from CCM and merkle proofs when it's used to verify the cross chain message in the Poly chain. type IChainListener interface { // Initialize with config Init(*config.ListenerConfig, *poly.SDK) error // Blocks to confirm Defer() int // New block check interval ListenCheck() time.Duration // Chain Id ChainId() uint64 // Optional: Fetch block header and header hash, used to submit to poly chain for verifications Header(height uint64) (header []byte, hash []byte, err error) // Optional: Last header sync state in poly chain. LastHeaderSync(uint64, uint64) (uint64, error) // Scan cross chain transactions included in the block Scan(uint64) ([]*msg.Tx, error) // Compose cross chain message before submit to poly chain Compose(*msg.Tx) error // Current chain height LatestHeight() (uint64, error) } 1.2 Implement Chain Submitter Chain Submitter is used to submit messages/transactions to the target chain, including bookkeeper changes of poly chain and cross chain messages. You can call the command via the following codes. type IChainSubmitter interface { // Initialize with config Init(*config.SubmitterConfig) error // Submit message/transaction to the chain Submit(msg.Message) error // Start the thread Start(context.Context, *sync.WaitGroup, bus.TxBus, bus.DelayedTxBus, msg.PolyComposer) error // Process the cross chain message from poly chain ProcessTx(*msg.Tx, msg.PolyComposer) error } 1.3 Development steps The poly-relayer project depends on the bridge-common library. Follow the listed steps to develop the relayer for a new chain. Add chain ID in the bridge-common project here. Add chain client SDK here for common usage. Add chain wallet here for common usage. Implement interface IChainListener and IChainSubmitter for the new chain. Register ChainListener and ChainSubmitter in selectors located in the relayer.go file. 2. Subcommands Execute settxblock to set the initial height of scanning../relayer_main settxblock --height 100210 --chain 7 Executesetheaderblock to set the header sync height../relayer_main setheaderblock --height 100210 --chain 7 Executestatus to check the current relayer status../relayer_main status Sample output:Status Bsc: Latest node height: 16656699 Latest sync height: 16656696 Header sync height: 16656696 Header mark height: 16656696 tx listen height : 16656682 header sync height diff: 3 tx listen height diff : 17 src tx queue size : 0 poly tx queue size: 0 3. Other Notes Please follow guide here for deployment. Check your wallet balance regularly to avoid problems caused by insufficient balance. Creating multiple wallet accounts can speed up cross chain transaction. Request a poly chain wallet before run the relayer, as signature in poly chain wallet is permitted by assigned accounts. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-24 17:07:51 "},"new_chain/launch_and_test/launch.html":{"url":"new_chain/launch_and_test/launch.html","title":"Launch and Test","keywords":"","body":"Launch and Test Till now, you may have completed the above three parts and waiting to run your module. Then you can execute launch and test by following the listed steps according to the needs of your project. 1. Deploy Contracts If you want to take templates provided by Poly as your CCM module, you need to deploy three contracts listed below: Deploy Cross Chain Data contract and get the address of it. Deploy Cross Chain Manager contract and input the address of Cross Chain Data contract. Deploy Cross Chain Manager Proxy contract and input the address of Cross Chain Manager contract. 2. Register Chain Registration is the prerequisite of monitoring and processing block information and checking the execution of cross-chain transactions. The chain will be officially involved into the cross-chain ecosystem after completing registration and being approved by the Cross Chain Council. Call entry function RegisterSideChain Call entry function ApproveRegisterSideChain [!NOTE] Chain registration is currently completed by poly team via the trusted account. 3. Synchronize genesis block header Genesis block header synchronization is the prerequisite of synchronizing and processing the subsequent block header information. It involves Synchronizing the genesis block header of the new chain to poly chain and synchronizing the genesis header of the poly chain to ccm contract of the new chain. Call entry function SyncSideChainGenesisHeader [!NOTE] Synchronization is currently completed by poly team via the trusted account. 4. Deploy Relayers Deployment of relayer involves two critical procedures: execute relayer subcommands below and deploy relayer. You can follow the listed commands and steps to complete your deployment. 4.1 Relayer Subcommands Execute settxblock to set the scan initial height../relayer_main settxblock --height 100210 --chain 7 Executesetheaderblock to set the header sync height../relayer_main setheaderblock --height 100210 --chain 7 Executestatus to show the current relayer status../relayer_main status Sample output:Status Bsc: Latest node height: 16656699 Latest sync height: 16656696 Header sync height: 16656696 Header mark height: 16656696 tx listen height : 16656682 header sync height diff: 3 tx listen height diff : 17 src tx queue size : 0 poly tx queue size: 0 4.2 Deployment steps: Now you can actually deploy your relayer with the following three steps: Step 1. Build the Binary To build the binary, switch to the right branch Branch Select, then run: ./build.sh devnet/testnet/mainnet Step 2. Write the Configuration Make sure necessory configuration is specifed in config.json Sample. Specify roles to enable in roles.json Sample Roles Quantity Demand Description HeaderSync One or multiple for each chain It submits chain headers to poly chain. TxListen Only one for each chain It observes cross chain transactions from source chain, and push them to message queue. TxCommit One or multiple for each chain It consumes the message queue, and submit the cross chain transactions to poly. PolyListen Only One for poly chain It observes cross chain transactions from poly chain and push them to message queue. PolyCommit One or multiple for poly chain It consumes the message queue, and submit the cross chain transaction to the destination chain. For Poly public nodes, contract addresses, please check here. Step 3. Run the Relayer Process ./server --config ./config.json --roles ./roles.json [!Note] Wallet balance should be checked regularly to avoid out of fee balance issue. Mulitple wallet accounts can be created to increase message relay throughout. Poly chain wallet signer address is permission controlled, so before run the relayer, the poly chain wallet should be requested. 5. Test Cross-chain using Lock proxy Cross-chain using Wrapper Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-24 17:51:21 "},"new_product/integrate_bridge/readme.html":{"url":"new_product/integrate_bridge/readme.html","title":"Build New Bridges","keywords":"","body":"Poly Docs Except for building a new chain, you may want to join poly cross-chain ecosystem via just connecting with Poly Bridge orintegrating the APIs provided by Poly Bridge into your own cross-chain bridge. Then, the listed information will be helpful for you. 1. Main Functions of Poly Bridge: [!NOTE] For now, Poly Bridge is deployed by the poly team. Monitor cross-chain eventDuring transaction, Poly Bridge will monitor the wrapper events emitted by the wrapper contract on the source chain, the lock event (on source chain) and unlock event (on target chain) emitted by CCM contracts. Link cross-chain eventsPoly Bridge links the events monitored from source chain, poly chain and target chain depending on the transaction key, and update the status of the cross-chain transaction simultaneously. Synchronize cross-chain feePoly Bridge will synchronize the transaction fee of target chain to facilitate users when they initiate a cross-chain transaction. Synchronize cross-chain token pricePoly Bridge also synchronizes the price of tokens both on source chain and target chain from the market, making users be informed about the exchange rate and accurately calculate transaction fee. 2. Integrate Poly Bridge APIs into Other Cross-chain Bridge. Even if you want to implement your own cross-chain bridge, you need to realize the four main functions mentioned above.And for your convenience, Poly Bridge also provides some API for you to integrate into your own cross-chain bridge. You can find them in here. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-25 14:54:22 "},"new_product/integrate_bridge/bridge.html":{"url":"new_product/integrate_bridge/bridge.html","title":"API","keywords":"","body":"API The following APIs are provided for developers who need to implement the bridge function. If you want to integrate into the poly bridge, please get in touch with the poly team via contact@poly.network or https://discord.com/invite/y6MuEnq for more support. Poly Bridge APIs: Get cross chain fee Get cross chain transaction status Get history transactions of address Get token basics information Get token mapping relationship between different chains Get the expected cross chain duration Get cross chain fee This API returns transaction fee which will be charged on the source chain in cross-chain transaction. And if SwapTokenHash is specified, the transferable amount will be returned. API Testnet: https://bridge.poly.network/testnet/v1/getfee Mainnet: https://bridge.poly.network/v1/getfee Parameter /* @SrcChainId: source chian id * @SwapTokenHash: the hahs of the cross-chain token on the source chain * @Hash: The token hash used to charge fees * @DstChainId: target chain id */ Example Request curl --location --request POST 'https://bridge.poly.network/testnet/v1/getfee' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"SrcChainId\": 2, \"SwapTokenHash\": \"0d9c8723b343a8368bebe0b5e89273ff8d712e3c\", \"Hash\": \"0000000000000000000000000000000000000000\", \"DstChainId\": 3 }' Example Response { \"SrcChainId\": 2, \"Hash\": \"0000000000000000000000000000000000000000\", \"DstChainId\": 3, \"UsdtAmount\": \"0.1874142096\", \"TokenAmount\": \"0.00006131\", \"TokenAmountWithPrecision\": \"6.1318011405463236515e+13\", \"SwapTokenHash\": \"0d9c8723b343a8368bebe0b5e89273ff8d712e3c\", \"Balance\": \"2.9553450781056623353e+41\", \"BalanceWithPrecision\": \"2.9553450781056623352e+47\" } Get the cross chain transaction status This API returns the details of the assigned hash, and you can view the cross-chain procedure through the TransactionState in the response. API Testnet: https://bridge.poly.network/testnet/v1//transactionofhash Mainnet: https://bridge.poly.network/v1/transactionofhash Parameter /* * @Hash: the cross chain transaction hash */ Example Request curl --location --request POST 'https://bridge.poly.network/testnet/v1//transactionofhash' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"Hash\": \"0b2c42b35e811b973c1d9258214cc68e63059271256bfb89239198cd1a7bda98\" }' Example Response { \"Hash\": \"4496cdb2905c148c06039a83d4130f04ddae498aa1065b06430ccd2766b08f78\", \"User\": \"547f1e7f552ec9701a8a4b4c30c6bbf3fff513cf\", \"SrcChainId\": 7, \"BlockHeight\": 12538043, \"Time\": 1644508161, \"DstChainId\": 6, \"FeeAmount\": \"2.59436134\", \"TransferAmount\": \"21926.387813549774936158\", \"DstUser\": \"bc7128144f31da5a1eff7c79e86d6c0b01af3de6\", \"ServerId\": 0, \"State\": 0, \"Token\": { \"Hash\": \"25d2e80cb6b86881fd7e07dd263fb79f4abe033c\", \"ChainId\": 7, \"Name\": \"MDX\", \"Property\": 1, \"TokenBasicName\": \"MDX\", \"Precision\": 18, \"AvailableAmount\": \"21578714598525328008311694\", \"TokenBasic\": { \"Name\": \"MDX\", \"Precision\": 18, \"Price\": \"0.28673118\", \"Ind\": 1, \"Time\": 1644508861, \"Property\": 1, \"Meta\": \"https://app.ont.io/poly/mdx.svg\", \"PriceMarkets\": null, \"Tokens\": null }, \"TokenMaps\": null }, \"FeeToken\": { \"Hash\": \"25d2e80cb6b86881fd7e07dd263fb79f4abe033c\", \"ChainId\": 7, \"Name\": \"MDX\", \"Property\": 1, \"TokenBasicName\": \"MDX\", \"Precision\": 18, \"AvailableAmount\": \"21578714598525328008311694\", \"TokenBasic\": null, \"TokenMaps\": null }, \"TransactionState\": [ { \"Hash\": \"4496cdb2905c148c06039a83d4130f04ddae498aa1065b06430ccd2766b08f78\", \"ChainId\": 7, \"Blocks\": 21, \"NeedBlocks\": 21, \"Time\": 1644508161 }, { \"Hash\": \"e93416eac8f52b9e1d7523ebecceb901b6cddb08d6c0e851903e52094f92cb77\", \"ChainId\": 0, \"Blocks\": 1, \"NeedBlocks\": 1, \"Time\": 1644508259 }, { \"Hash\": \"8d9cfefed98e22015f6baab9ab5abb9b33e8ca2b70003a774f12a90a8bb65273\", \"ChainId\": 6, \"Blocks\": 1, \"NeedBlocks\": 1, \"Time\": 1644508270 } ] } Get history transactions of address This API returns the cross-chain history of the assigned address. API Testnet: https://bridge.poly.network/testnet/v1/transactionsofaddress Mainnet: https://bridge.poly.network/v1/transactionsofaddress Parameter /* @Addresses: wallet address * @PageNo: start page * @PageSize: size of displays per page */ Example Request curl --location --request POST 'https://bridge.poly.network/testnet/v1/transactionsofaddress' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"Addresses\": [ \"93aea6537acd6c10ed76ea8eb367c2ae4cfa2282\" ], \"PageNo\": 0, \"PageSize\": 10 }' Example Response { \"PageSize\": 1, \"PageNo\": 0, \"TotalPage\": 1, \"TotalCount\": 1, \"Transactions\": [ { \"Hash\": \"0b2c42b35e811b973c1d9258214cc68e63059271256bfb89239198cd1a7bda98\", \"User\": \"aecb8dff86f198ad3a812a00035438e553b230bd\", \"SrcChainId\": 88, \"BlockHeight\": 1163947, \"Time\": 1644997356, \"DstChainId\": 7, \"FeeAmount\": \"0.00023409\", \"TransferAmount\": \"1.23\", \"DstUser\": \"93aea6537acd6c10ed76ea8eb367c2ae4cfa2282\", \"ServerId\": 0, \"State\": 0, \"Token\": { \"Hash\": \"d2a4cff31913016155e38e474a2c06d08be276cf\", \"ChainId\": 88, \"Name\": \"GAS\", \"Property\": 1, \"TokenBasicName\": \"GAS\", \"Precision\": 8, \"AvailableAmount\": \"39455668193977\", \"TokenBasic\": { \"Name\": \"GAS\", \"Precision\": 8, \"Price\": \"5.50686187\", \"Ind\": 1, \"Time\": 1645095305, \"Property\": 1, \"Meta\": \"\", \"PriceMarkets\": null, \"Tokens\": null }, \"TokenMaps\": null }, \"FeeToken\": { \"Hash\": \"d2a4cff31913016155e38e474a2c06d08be276cf\", \"ChainId\": 88, \"Name\": \"GAS\", \"Property\": 1, \"TokenBasicName\": \"GAS\", \"Precision\": 8, \"AvailableAmount\": \"39455668193977\", \"TokenBasic\": null, \"TokenMaps\": null }, \"TransactionState\": [ { \"Hash\": \"0b2c42b35e811b973c1d9258214cc68e63059271256bfb89239198cd1a7bda98\", \"ChainId\": 88, \"Blocks\": 1, \"NeedBlocks\": 1, \"Time\": 1644997356 }, { \"Hash\": \"331287ddc15029faa160dcf3846a57471d21b7b817fabbcd87e3fe4b80d89130\", \"ChainId\": 0, \"Blocks\": 1, \"NeedBlocks\": 1, \"Time\": 1644997377 }, { \"Hash\": \"42e45d1bdddc9bd3b63979676fd99f928fa741ea28a806cf385c001ac36ba101\", \"ChainId\": 7, \"Blocks\": 1, \"NeedBlocks\": 1, \"Time\": 1644997384 } ] } ] } Get token basics information This API returns the basic information of the token, including price, precision, meta data and the token information mapped on each chain. API Testnet: https://bridge.poly.network/testnet/v1/tokenbasics Mainnet: https://bridge.poly.network/v1/tokenbasics Parameter none Example Request curl --location --request POST 'https://bridge.poly.network/testnet/v1/tokenbasics' Example Response { \"TotalCount\": 2, \"TokenBasics\": [ { \"Name\": \"8PAY\", \"Precision\": 18, \"Price\": \"1\", \"Ind\": 1, \"Time\": 0, \"Property\": 1, \"Meta\": \"https://app.ont.io/poly/8pay.jpg\", \"PriceMarkets\": null, \"Tokens\": [ { \"Hash\": \"48abb7954b5bc46be41cc444e731f9d03aa33feb\", \"ChainId\": 79, \"Name\": \"8pay\", \"Property\": 1, \"TokenBasicName\": \"8PAY\", \"Precision\": 18, \"AvailableAmount\": \"28254867780000000000\", \"TokenBasic\": null, \"TokenMaps\": null }, { \"Hash\": \"aa00fbcface6ff4913cc8322b12f63e2ad45d448\", \"ChainId\": 2, \"Name\": \"8pay\", \"Property\": 1, \"TokenBasicName\": \"8PAY\", \"Precision\": 18, \"AvailableAmount\": \"71745132220000000000\", \"TokenBasic\": null, \"TokenMaps\": null } ] } ] } Get token mapping relationship between different chains This API returns mapping relations between source chain and target chain of assigned token. API Testnet: https://bridge.poly.network/testnet/v1/tokenmap Mainnet：https://bridge.poly.network/v1/tokenmap Parameter /* @ChainId: source chain id * @Hash: source token hash */ Example Request curl --location --request POST 'https://bridge.poly.network/testnet/v1/tokenmap' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"ChainId\": 79, \"Hash\": \"48abb7954b5bc46be41cc444e731f9d03aa33feb\" }' Example Response { \"TotalCount\": 1, \"TokenMaps\": [ { \"SrcTokenHash\": \"48abb7954b5bc46be41cc444e731f9d03aa33feb\", \"SrcToken\": { \"Hash\": \"48abb7954b5bc46be41cc444e731f9d03aa33feb\", \"ChainId\": 79, \"Name\": \"8pay\", \"Property\": 1, \"TokenBasicName\": \"8PAY\", \"Precision\": 18, \"AvailableAmount\": \"28254867780000000000\", \"TokenBasic\": null, \"TokenMaps\": null }, \"DstTokenHash\": \"aa00fbcface6ff4913cc8322b12f63e2ad45d448\", \"DstToken\": { \"Hash\": \"aa00fbcface6ff4913cc8322b12f63e2ad45d448\", \"ChainId\": 2, \"Name\": \"8pay\", \"Property\": 1, \"TokenBasicName\": \"8PAY\", \"Precision\": 18, \"AvailableAmount\": \"71745132220000000000\", \"TokenBasic\": null, \"TokenMaps\": null }, \"Property\": 1 } ] } Get the expected cross chain duration This API returns the expected elapsed time for token to transfer from source chain to target chain. API Testnet: https://bridge.poly.network/testnet/v1/expecttime Mainnet：https://bridge.poly.network/v1/expecttime Parameter /* @SrcChainId: source chain id * @DstChainId: target token hash */ Example Request curl --location --request POST 'https://bridge.poly.network/testnet/v1/expecttime' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"SrcChainId\": 79, \"DstChainId\": 2 }' Example Response { \"TotalCount\": 1, \"TokenMaps\": [ { \"SrcTokenHash\": \"48abb7954b5bc46be41cc444e731f9d03aa33feb\", \"SrcToken\": { \"Hash\": \"48abb7954b5bc46be41cc444e731f9d03aa33feb\", \"ChainId\": 79, \"Name\": \"8pay\", \"Property\": 1, \"TokenBasicName\": \"8PAY\", \"Precision\": 18, \"AvailableAmount\": \"28254867780000000000\", \"TokenBasic\": null, \"TokenMaps\": null }, \"DstTokenHash\": \"aa00fbcface6ff4913cc8322b12f63e2ad45d448\", \"DstToken\": { \"Hash\": \"aa00fbcface6ff4913cc8322b12f63e2ad45d448\", \"ChainId\": 2, \"Name\": \"8pay\", \"Property\": 1, \"TokenBasicName\": \"8PAY\", \"Precision\": 18, \"AvailableAmount\": \"71745132220000000000\", \"TokenBasic\": null, \"TokenMaps\": null }, \"Property\": 1 } ] } Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-25 11:24:45 "},"new_product/integrate_bridge/launch.html":{"url":"new_product/integrate_bridge/launch.html","title":"Launch and Test","keywords":"","body":"Launch and Test [!NOTE] For now, Poly Bridge is deployed by the poly team. 1. Environmental Requirements: Make sure your device has got access to the Internet; Make sure your device has installed and launched: golang>=1.17 and git. 2. Deploy Bridge Server and Bridge Http Under the required environment, you can deploy bridge server and bridge http separately to launch your Poly Bridge. Step 1. Clone code Firstly, you have to clone the core code from the remote repository of polynetwork. Run git bash in your assigned file and to do so: git clone https://github.com/polynetwork/poly-bridge.git Step 2. Build binaries Then build bridge server and bridge http binaries separately via: # Compile the bridge server go build -o bridge_server -tags testnet/mainnet ./cmd/ # Compile the bridge http go build -o bridge_http -tags testnet/mainnet ./ Step 3. Configuration Make sure necessary configurations are specified in config.json DBConfig RedisConfig ChainNodes ChainListenConfig FeeListenConfig CoinPriceListenConfig Here we provide a configuration example, and for more details, please refer to here { \"DBConfig\": { \"Debug\": true, \"URL\": \"localhost:3306\", \"Scheme\": \"poly\", \"User\": \"root\", \"Password\": \"123\" }, \"RedisConfig\": { \"addr\": \"redis:6379\", \"password\": \"123\", \"proto\": \"tcp\", \"pool_size\": 50, \"min_idle_conns\": 10, \"dial_timeout\": 2, \"read_timeout\": 2, \"write_timeout\": 2, \"idle_timeout\": 10, \"expiration\": 600 }, \"ChainNodes\": [ { \"ChainName\": \"Poly\", \"ChainId\": 0, \"Nodes\": [ { \"Url\": \"http://124.156.226.204:20336\" } ] }, { \"ChainName\": \"Ethereum\", \"ChainId\": 2, \"Nodes\": [ { \"Url\": \"https://ropsten.infura.io/v3/xxx\" } ] } ], \"ChainListenConfig\": [ { \"ChainName\": \"Poly\", \"ChainId\": 0, \"ListenSlot\": 1, \"Defer\": 1, \"BatchSize\": 5, \"CCMContract\": \"0300000000000000000000000000000000000000\" }, { \"ChainName\": \"Ethereum\", \"ChainId\": 2, \"ListenSlot\": 5, \"Defer\": 1, \"BatchSize\": 5, \"WrapperContract\": [ \"e498fb7D00468a67A79dE5D4Ca264d3350165280\", \"Dc37471Af6a8aB7f45F444c5a3Ef4758281bE32C\" ], \"CCMContract\": \"f989E80AAd477cB6059f366C0170a498909C4a55\", \"ProxyContract\": [ \"D8aE73e06552E270340b63A8bcAbf9277a1aac99\" ], \"SwapContract\": \"1E7A3e54494F300dC66181621E23eE657E22D725\", \"NFTWrapperContract\": [ \"940300dc3Fc26e3A330a300be766184C0b5Fe019\" ], \"NFTProxyContract\": [ \"9bEF1AE7304D3d2F344ea00e796ADa18cE1beb03\" ], \"NFTQueryContract\": \"500674D603331C43ed2288834BAb284BF65fc076\" } ], \"FeeListenConfig\": [ { \"ChainId\": 2, \"ChainName\": \"Ethereum\", \"GasLimit\": 120000, \"ProxyFee\": 120, \"MinFee\": 80 } ], \"CoinPriceListenConfig\": [ { \"MarketName\": \"coinmarketcap\", \"Nodes\": [ { \"Url\": \"https://pro-api.coinmarketcap.com/v1/cryptocurrency/\", \"Key\": \"xxx\" } ] }, { \"MarketName\": \"binance\", \"Nodes\": [ { \"Url\": \"https://api1.binance.com/\" } ] } ] } Step 4. Run Now you can launch and run the two functions: ./bridge_server --config config.json ./bridge_http --config config.json Step 5. Test There are detailed unit tests in the code repository, which can be tested as needed before the service starts. And after the service starts, you need to check the log for errors, such as program panic, node connection failure, etc. Additionally you need to pay attention to whether the monitoring height of the chain increases normally. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-25 14:55:51 "},"new_product/integrate_assets/readme.html":{"url":"new_product/integrate_assets/readme.html","title":"Import New Assets","keywords":"","body":"Import New Assets This part is mainly to help the project import assets into the Poly Network. Poly Network already supports most mainstream chains, check if your project supports existing chains. Both Token and NFT can be cross-chained on Poly Network. Whether or not there is an asset on the target chain, Poly Network can help you complete it. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-21 10:44:47 "},"new_product/integrate_assets/assets.html":{"url":"new_product/integrate_assets/assets.html","title":"Steps for Importing","keywords":"","body":"Steps for Importing Step1. Download Asset Template Download the asset template of Poly Network. Step2. Fill in the Asset Information Fill in the asset information according to eg in excel Step3. Connect Poly Network Contact the poly administrator at TG: https://t.me/joinchat/Hjv5NBrfO1C2LyODQfxVDw Send asset information. Tell administrators which chains have no asset contracts. [!Note] If there is no asset on the target chain, Poly Team will deploy a mapped asset to the target chain, and at the same time, it will enter all the assets into the lockproxy contract of the target chain.That is to say, the mapped assets are only valuable when they are unlocked. [!Note] If you already have a corresponding asset contract on the target chain, then Poly Team will use the pip4 contract to cross-chain. When you add liquidity, it will give you a corresponding LP-asset, and LP-asset can cross-chain. When the liquidity is insufficient , requires you to continue to add liquidity. Step4. Cross-chain testing You can see your assets on the Poly Bridge, and then you can perform cross-chain testing. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-21 10:44:47 "},"new_product/integrate_assets/launch.html":{"url":"new_product/integrate_assets/launch.html","title":"Launch and Test","keywords":"","body":"Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-21 10:44:47 "},"new_product/integrate_contracts/readme.html":{"url":"new_product/integrate_contracts/readme.html","title":"Customize Business Logic Contracts","keywords":"","body":"Customize Business Logic Contracts You can write your own business logic contract both on source chain and target chain. CCM contract remains two interfaces for direct interconnection with customized business logic contracts. Here, this section introduces you the process of cross-chain interconnection, and how to build your own business logic contract and join into the vast cross-chain ecosystem. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-25 17:08:48 "},"new_product/integrate_contracts/Customizing Business Logic Contract.html":{"url":"new_product/integrate_contracts/Customizing Business Logic Contract.html","title":"Guidelines for Developing","keywords":"","body":"Guidelines for Developing Develop Customized Business Logic Contracts Chains must and only must be deployed with one CCM contract so as to implement cross-chain features. And for normal running, all the business logic contracts have to interconnect with CCM contract via the interfaces offered by CCM contract. See the following for detailed description or refer to the full code of CCM contract. [!Note|style:flat|label:Notice] To implement cross-chain features, you need to make sure that the cross chain methods in your business logic contracts have authorized our Cross Chain Manager Contract to call. Step1. Implement methods of inputting the mapping relationship Except for verifying the existence of transaction through CCM contract, business logic contract needs to make sure the accuracy of the assets relationship in the transaction. Therefore, the business contract should maintain both the asset mapping and business logic contract mapping. Asset hash is mapped from the source chain to the target chain, and target chain Id is mapped to the business logic contract address on target chain. Example: The asset mapping relationship stored in business logic contract will help complete transaction data. Binding actions also prevent the wrong input from users which may lead to transfer assets to wrong asset contract address. pragma solidity ^0.5.0; import \"./../../libs/ownership/Ownable.sol\"; contract LockProxy is Ownable { address public managerProxyContract; mapping(uint64 => bytes) public proxyHashMap; mapping(address => mapping(uint64 => bytes)) public assetHashMap; // toChainId: the target chain id // targetProxyHash: the address of business logic contract on target chain function bindProxyHash(uint64 toChainId, bytes memory targetProxyHash) onlyOwner public returns (bool) { proxyHashMap[toChainId] = targetProxyHash; emit BindProxyEvent(toChainId, targetProxyHash); return true; } // fromAssetHash: asset hash on source chain // toAssetHash: asset hash on target chain function bindAssetHash(address fromAssetHash, uint64 toChainId, bytes memory toAssetHash) onlyOwner public returns (bool) { assetHashMap[fromAssetHash][toChainId] = toAssetHash; emit BindAssetEvent(fromAssetHash, toChainId, toAssetHash, getBalanceFor(fromAssetHash)); return true; } } Step2. Implement methods of initiating a cross-chain request Interface: This interface creates cross-chain transactions, invoked by business logic contracts when a cross chain function is carried out in the logic contract. /* * @param toChainId The target chain id * @param toAddress The address in bytes format to receive same amount of tokens in target chain * @param toContract Target smart contract address in bytes in target block chain * @param txData Transaction data for target chain, include toAssetHash, toAddress, amount * @return true or false */ function crossChain(uint64 toChainId, bytes calldata toContract, bytes calldata method, bytes calldata txData) whenNotPaused external returns (bool) This method constructs the rawParam, which contains transaction hash, msg.sender, target chain ID, business logic contract to be invoked on target chain, the target method to be invoked, and the serialized transaction data which has been already constructed in business logic contract. Then put the hash of rawParam into storage, to prove cross-chain transaction. Example: /* * @param fromAssetHash The asset address in current chain * @param toChainId The target chain id * @param toAddress The address in bytes format to receive same amount of tokens in target chain * @param amount The amount of tokens to be crossed from ethereum to the chain with chainId */ function lock(address fromAssetHash, uint64 toChainId, bytes memory toAddress, uint256 amount) public payable returns (bool) { require(amount != 0, \"amount cannot be zero!\"); require(_transferToContract(fromAssetHash, amount), \"transfer asset from fromAddress to lock_proxy contract failed!\"); bytes memory toAssetHash = assetHashMap[fromAssetHash][toChainId]; require(toAssetHash.length != 0, \"empty illegal toAssetHash\"); TxArgs memory txArgs = TxArgs({ toAssetHash: toAssetHash, toAddress: toAddress, amount: amount }); bytes memory txData = _serializeTxArgs(txArgs); IEthCrossChainManagerProxy eccmp = IEthCrossChainManagerProxy(managerProxyContract); address eccmAddr = eccmp.getEthCrossChainManager(); IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr); bytes memory toProxyHash = proxyHashMap[toChainId]; require(toProxyHash.length != 0, \"empty illegal toProxyHash\"); require(eccm.crossChain(toChainId, toProxyHash, \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\"); emit LockEvent(fromAssetHash, _msgSender(), toChainId, toAssetHash, toAddress, amount); return true; } This function is invoked by users. Users can request a cross-chain transaction through the dApp which works in source chain, and then business logic contract will get the transaction information involving asset contract address on source chain, target chain ID, target address and amount of token to be transferred. By calling this method, business logic contract will lock the certain amount to asset contract; Then the transaction data will be packed, which then in turn invokes the CCM contract. The management contract transfers the parameters of transaction data to the target chain and a cross chain transaction is created by management contract which is sent to the target chain based on block generation on source chain; The serialized transaction data, along with chain ID, business logic contract address of target chain and the method needing to be called on target chain, will be sent through crossChain() in CCM contract. Step3. Implement methods of verifying and executing cross-chain transactions Interface: This method is invoked by relayer, but in some cases users could also invoke this method by themselves if they get the valid block information from Poly. /* * @param proof Poly chain transaction merkle proof * @param rawHeader The header containing crossStateRoot to verify the above tx merkle proof * @param headerProof The header merkle proof used to verify rawHeader * @param curRawHeader Any header in current epoch consensus of Poly chain * @param headerSig The coverted signature veriable for solidity derived from Poly chain consensus nodes' signature * used to verify the validity of curRawHeader * @return true or false */ function verifyHeaderAndExecuteTx(bytes memory proof, bytes memory rawHeader, bytes memory headerProof, bytes memory curRawHeader, bytes memory headerSig) whenNotPaused public returns (bool) This method fetches and processes cross chain transactions, finds the merkle root of a transaction based on the block height (in the block header), and verifies the legitimacy of transaction using the transaction parameters. After verifying Poly chain block header and proof, it will invoke the business logic contract deployed on the target chain. Invoking will be processed through the internal method _executeCrossChainTx(): This method is meant to invoke the target contract, and trigger executation of cross chain tx on target chain. Firstly, we need to ensure the target contract gonna be invoked is indeed a contract rather than a normal account address. Then we construct a method calling on target business logic contract: first we need to encodePacked the _method and the format of input data \"(bytes,bytes,uint64)\". Then it would keccak256 the encoded string, use bytes4 to take the first four bytes of the call data for a function call specifies the function to be called. Parameter _method is from the toMerkleValue , which is parsed from proof. And the input parameters format is restricted as (bytes _args, bytes _fromContractAddr, uint64 _fromChainId). These two parts are encodePacked as a method call. After calling the method, we need to check the return value. Only if the return value is true, will the whole cross chain transaction be executed successfully. Example: /* * @param argsBs The argument bytes recevied by the lock proxy contract on source chain, * need to be deserialized based on the way of serialization in the * lock proxy contract on source chain . * @param fromContractAddr The source chain contract address * @param fromChainId The source chain id */ function unlock(bytes memory argsBs, bytes memory fromContractAddr, uint64 fromChainId) onlyManagerContract public returns (bool) { TxArgs memory args = _deserializeTxArgs(argsBs); require(fromContractAddr.length != 0, \"from proxy contract address cannot be empty\"); require(Utils.equalStorage(proxyHashMap[fromChainId], fromContractAddr), \"From Proxy contract address error!\"); require(args.toAssetHash.length != 0, \"toAssetHash cannot be empty\"); address toAssetHash = Utils.bytesToAddress(args.toAssetHash); require(args.toAddress.length != 0, \"toAddress cannot be empty\"); address toAddress = Utils.bytesToAddress(args.toAddress); require(_transferFromContract(toAssetHash, toAddress, args.amount), \"transfer asset from lock_proxy contract to toAddress failed!\"); emit UnlockEvent(toAssetHash, toAddress, args.amount); return true; } This function is invoked by CCM contract. It deserializes the transaction data and invokes the asset contract to release the tokens to target address. verifyHeaderAndExecuteTx() in CCM contract determines the legitimacy of the cross chain transaction information and resolve the parameters of transaction data from the Poly chain transaction merkle proof and crossStateRoot contained in the block header. After verification through Poly, the packed transaction data could be executed on target chain. Then call the function unlock() to deserialize the transaction data and unlock (transfer) the certain amount of token to the target address on target chain and completes the cross chain contract invocation. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-25 17:02:52 "},"new_product/integrate_contracts/launch.html":{"url":"new_product/integrate_contracts/launch.html","title":"Launch and Test","keywords":"","body":"Launch and Test 1. Deploying Contracts To implement cross chain features, you need to make sure that: The customized business logic contracts are deployed both on source chain and target chain The cross chain methods in your business logic contracts have authorized our Cross Chain Manager Contract to call. The mapping assets need to be bound before any cross chain transactions 2. Test Your Contracts We highly encourage project developers to test the business logic contract on testnet before launching on mainnet. If you want to test your contract on mainnet directly, you need to provide us with the business logic contract addresses and cross-chain methods both on source chain and target chain, so that we could maintain the whitelist of CCM contract, which is meant to guarantee the safety of cross chain process. Following are the tests required to be done before launching project: Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-25 16:53:09 "},"Core_Smart_Contract/Contract/MainNet.html":{"url":"Core_Smart_Contract/Contract/MainNet.html","title":"MainNet","keywords":"","body":" MainNet | TestNet | DevNet Here are cross chain contracts ONLY working in MAINNET mode, which are used to bind asset mapping in different chains. It refers to that the asset is mapping if the name ends with (s). Contract Index (Chain-Chain ID) Bitcoin-1 Ethereum-2 Ontology-3 Neo Legacy-4 Switcheo-5 BSC-6 Heco-7 Palette-8 Curve-10 OKEx-12 Neo N3-14 Heimdall-15 Polygon-17 Zilliqa-18 Arbitrum-19 xDAI-20 Avalanche-21 Fantom-22 Optimistic-23 Metis-24 Quick Index Router And Chain ID BTC Type Contract Desc Back to top Ethereum Type Contract Desc CCMP 0x5a51e2ebf8d136926b9ca7b59b60464e7c44d2eb Ethereum Cross Chain Manager Proxy contract CCD 0xcf2afe102057ba5c16f899271045a0a37fcb10f2 Ethereum Cross Chain Data contract CCM 0x14413419452Aaf089762A0c5e95eD2A13bBC488C Ethereum Cross Chain Manager contract Lock Proxy 0x250e76987d838a75310c34bf422ea9f1AC4Cc906 Ethereum Asset Proxy contract Wrapper 0x2aA63cd0b28FB4C31fA8e4E95Ec11815Be07b9Ac WrapperV1 that takes transferred asset as fee WrapperV2 0xd380450e9e373bDC389951C54616edb2EE653524 WrapperV2 that takes native asset as fee Swapper 0xaf83ce8d461e8834de03a3803c968615013c6b3d Curve entrance for auto cross chain tx with fee NFT Lock Proxy 0x2cdfc90250EF967036838DA601099656e74bCfc5 NFT Lock Proxy contract NFT Wrapper 0xe5204d62361A353C665668C858Ea213070CA159c NFT Wrapper contract NFT Query 0xB2265A122814dA516318F727183a5D8FeCA8BaCE NFT profile query contract PLT NFT Lock Proxy 0xD33e44F6E4fE37C4dF23c7171657721B9A725417 Contract of dedicated Palette NFT Lock Proxy PLT NFT Wrapper 0xD728e9844af285fA116806c273aa413686aE65e8 Contract of dedicated Palette NFT Wrapper PLT NFT Wrapper Fee collecotr 0x0E860F44d73F9FDbaF5E9B19aFC554Bf3C8E8A57 Fee collector address of dedicated Palette NFT wrapper Back to top Ontology Type Contract Desc Lock Proxy B: 86b4ab5d99037113867247a1e68f70e348c07597 L: 9775c048e3708fe6a1477286137103995dabb486 ONT with 9 decimal contract Wrapper B: c93837e82178d406af8c84e1841c6960af251cb5 L: b51c25af60691c84e1848caf06d47821e83738c9 WrapperV1 that takes transferred asset as fee Back to top Neo Type Contract Desc CCM B: 0x82a3401fb9a60db42c6fa2ea2b6d62e872d6257f L: 7f25d672e8626d2beaa26f2cb40da6b91f40a382 Neo Cross Chain Manager contract Lock Proxy B: 0xe7fb2e1d937e71dbbb512e6375746181127282e7 L: e782721281617475632e51bbdb717e931d2efbe7 Neo Asset Proxy contract Back to top Neo N3 Type Contract Desc CCM B: 0x5ba6c543c5a86a85e9ab3f028a4ad849b924fab9 L: b9fa24b949d84a8a023fabe9856aa8c543c5a65b Neo N3 Cross Chain Manager contract Nep17 Proxy B: 0x385501cb0288b2953db767b0dc971478539456cb L: cb569453781497dcb067b73d95b28802cb015538 Neo N3 Asset Proxy contract Back to top Note B means big-endian, we can search the contract transaction history in corresponding explorer. L means little-endian, we usually use it as the asset input when we do binding asset operation. Back to top BSC Type Contract Desc CCMP 0xABD7f7B89c5fD5D0AEf06165f8173b1b83d7D5c9 BSC Cross Chain Manager Proxy contract CCD 0x11e2A718d46EBe97645b87F2363AFE1BF28c2672 BSC Cross Chain Data contract CCM 0x1c9Ca8aBb5da65d94DaD2E8Fb3f45535480d5909 BSC Cross Chain Manager contract Lock Proxy 0x2f7ac9436ba4B548f9582af91CA1Ef02cd2F1f03 BSC Asset Proxy contract Lock Proxy_1 0xfB571d4dd7039f96D34bB41E695AdC92dF4A332f BSC Asset Proxy contract Lock Proxy-PIP4 0x960Ff3132b72E3F0b1B9F588e7122d78BB5C4946 BSC Asset Proxy with LP contract Wrapper 0xE3D0FB6E3cB5DA61EB18b06D035052441009d1E6 WrapperV1 that takes transferred asset as fee WrapperV2 0x4b0CFdb5e1Ca898a225F9E14AfF9e4eF178a10d2 WrapperV2 that takes native asset as fee WrapperV3 0xbc3B4E7517c06019F30Bf2f707eD2770b85f9928 WrapperV3 that takes native asset as fee Swapper 0x00b93851e3135663AAeC351555EddEE5B01325e6 Curve entrance for auto cross chain tx with fee NFT Lock Proxy 0x2cdfc90250EF967036838DA601099656e74bCfc5 NFT Lock Proxy contract NFT Wrapper 0xe2bD9dD8FAF5C4C2087Ab82eC7E63F619CcAa152 NFT Wrapper contract NFT Query 0x02015dBb2Dc25Cc7313D7EDb4785c2C46F3B7FD2 NFT profile query contract Back to top HECO Type Contract Desc CCMP 0xABD7f7B89c5fD5D0AEf06165f8173b1b83d7D5c9 Heco Cross Chain Manager Proxy contract CCD 0x11e2A718d46EBe97645b87F2363AFE1BF28c2672 Heco Cross Chain Data contract CCM 0x7109c5F898C5667941B3D2A6451b4bFBeD2bdBbF Heco Cross Chain Manager contract Lock Proxy 0x020c15e7d08A8Ec7D35bCf3AC3CCbF0BBf2704e6 Heco Asset Proxy contract Wrapper 0x4fE451186c0D69205ACc1fA00FD75fc6d71e47eE WrapperV1 that takes transferred asset as fee WrapperV2 0x1B0C55be400e2a7D924032B257Fbc75Bbfd256E7 WrapperV2 that takes native asset as fee Swapper 0xD98Ee7Ca1B33e60C75E3cd9493c566fc857592c8 Curve entrance for auto cross chain tx with fee NFT Lock Proxy 0x2cdfc90250EF967036838DA601099656e74bCfc5 NFT Lock Proxy contract NFT Wrapper 0xe2bD9dD8FAF5C4C2087Ab82eC7E63F619CcAa152 NFT Wrapper contract NFT Query 0x56C9491F2aC2Bc623AB890D2Db16C98E1aBd1FBd NFT profile query contract Back to top Curve Type Contract Desc CCMP 0x25293B33DE6c7097A27b6c12888a15e0AbFf3A00 Curve Cross Chain Manager Proxy contract CCD 0xd57Dc9E14Be808b514D30fC5e46a07Ba1e5Cf473 Curve Cross Chain Data contract CCM 0x89D15F45597816C90cbafd32D0Bb8Fc99bE0B76f Curve Cross Chain Manager contract SwapProxy 0x34d4a23A1FC0C694f0D74DDAf9D8d564cfE2D430 Curve Asset Proxy contract BindProxy 0x46829549E0a5Eccb04737eEaC6cE8826169BA1f1 Curver bindproxy contract Pool-1 0xa6157DaBDda80F8c956962AB7739f17F54BAAB7F USDT-BUSD-HUSD pool address in Curve Pool-2 0x560470C9C6E45fBe47c792E90B691015f0614A9c ETH pool address in Curve Pool-3 0xd709d95479Fe244b27A34441D497859960893Ec6 BNB pool address in Curve Pool-4 0x6c27318a0923369de04df7Edb818744641FD9602 BTC pool address in Curve Pool-5 0x6C12415f6Ca74e5D1F091415858de7E188B0884C BTC pool address in Curve Pool-7 0x1EEcE3d9fD152b73728aba136BB6E1f3ebd2Afa2 USDT pool address in Curve Pool-8 0x6a07A0520C122f247Df2Fa3129Cc85F70f5485Fc USDC pool address in Curve Pool-10 0x58AD8FF9B7A9c85EeaDedCFdAD1f9bCfF7DA47f3 USDT pool address in Curve Back to top OKEx Type Contract Desc CCMP 0x4739fe955BE4704BcB7d6a699823F5B29217Baf6 OKEx Cross Chain Manager Proxy contract CCD 0xdb3A0149f3155cC1B6890FE382d309dB4b322630 OKEx Cross Chain Data contract CCM 0x6CE66Cf89A17B5C22e757cca01beAD901fC8C7f2 OKEx Cross Chain Manager contract Lock Proxy 0x9a3658864Aa2Ccc63FA61eAAD5e4f65fA490cA7D OKEx Asset Proxy contract Wrapper 0x11e2A718d46EBe97645b87F2363AFE1BF28c2672 WrapperV1 that takes transferred asset as fee WrapperV2 0xbd4a08577476A521C41a21EF3f00b045b74175d5 WrapperV2 that takes native asset as fee Swapper 0xb68C0D092842a4a0272867D89245FCD7e7fcA3Eb Curve entrance for auto cross chain tx with fee Back to top Polygon Type Contract Desc CCMP 0x5366ea2b5b729ff3cef404c2408c8c60cc061b71 Polygon Cross Chain Manager Proxy contract CCD 0x7cea671dabfba880af6723bddd6b9f4caa15c87b Polygon Cross Chain Data contract CCM 0xB16FED79a6Cb9270956f045F2E7989AFfb75d459 Polygon Cross Chain Manager contract Lock Proxy 0x28ff66a1b95d7cacf8eded2e658f768f44841212 Polygon Asset Proxy contract Wrapper 0x4493fb5dc195900938CC23096C7EEdEfc434e283 WrapperV1 that takes transferred asset as fee WrapperV2 0xB88f13682F3C602aCD84B4b2eEB96A9DD75Afd89 WrapperV2 that takes native asset as fee NFT Lock Proxy 0x359596463F4F4e5969330D74504A614c22885D62 NFT Lock Proxy contract NFT Wrapper 0x6cEB2EC1E82880812F6aA60DfA260679D6C8323d NFT Wrapper contract NFT Query 0x6AF09953541c7b4d0023c5E5a4241F82C68E986C NFT profile query contract Swapper 0xaC57280B3A657A2e8D1180493C519a476D208F61 Curve entrance for auto cross chain tx with fee Back to top Switcheo Type Denom (coin name) Asset/Contract Desc Back to top Palette Type Contract Desc CCD 0x250e76987d838a75310c34bf422ea9f1AC4Cc906 Palette Cross Chain Data contract CCM 0x1b02EEE12A7bF02922113a70d3D343De4b43f776 Palette Cross Chain Manager contract CCMP 0x7622058504412D5183352A7d350653DfFe58b1DC Palette Cross Chain Manager Proxy contract PLT Wrapper 0x0A9C412633465fdeE4861CeE02987386100bEAe6 WrapperV1 that takes transferred asset as fee NFT Lock proxy 0xdCA22CbA4a2d3dA3883b479f824F2147efed1718 NFT Lock Proxy contract NFT Wrapper 0x41985E2A8826233618392e38d46d2060fbCC3F2A NFT Wrapper contract NFT Query 0x0F05299e6ab0FbB3258296d3Ae7bF6Ae53A0c414 NFT profile query contract NFT Fee Collector 0x0E860F44d73F9FDbaF5E9B19aFC554Bf3C8E8A57 Fee collector address of palette NFT wrapper Back to top Zilliqa Type Contract Desc CCMP 0xfeafd3bb477c2d29ed078256698c7d9c37abcf20 Zilliqa Cross Chain Manager Proxy contract CCM 0xac9f601679a285c3ff0d95239a1dc7a7983df32d Zilliqa Cross Chain Manager contract Lock Proxy 0xd73c6b871b4d0e130d64581993b745fc938a5be7 Zilliqa Asset Proxy contract Back to top Arbitrum Type Contract Desc CCMP 0xABD7f7B89c5fD5D0AEf06165f8173b1b83d7D5c9 Arbitrum Cross Chain Manager Proxy contract CCM 0x7ceA671DABFBa880aF6723bDdd6B9f4caA15C87B Arbitrum Cross Chain Manager contract CCD 0x11e2A718d46EBe97645b87F2363AFE1BF28c2672 Arbitrum Cross Chain Data contract Lock Proxy 0x2f7ac9436ba4B548f9582af91CA1Ef02cd2F1f03 Arbitrum Asset Proxy contract Swapper 0x7E418a9926c8D1cbd09CC93E8051cC3BbdfE3854 Arbitrum Swapper contract Wrapper 0xCf018d59B4728d073bd961ABe6A8024A8F0A3cdB WrapperV1 that takes transferred asset as fee WrapperV2 0x0f8C16BA16E58525Eb2aDc231ff360cfa00bB527 WrapperV2 that takes native asset as fee Back to top xDAI Type Contract Desc CCMP 0x28FF66a1B95d7CAcf8eDED2e658f768F44841212 xDAI Cross Chain Manager Proxy contract CCM 0x2f7ac9436ba4B548f9582af91CA1Ef02cd2F1f03 xDAI Cross Chain Manager contract CCD 0x4D6934E2bb813f48DC0A7bf7Ead0365D9c894163 xDAI Cross Chain Data contract Lock Proxy 0x77F3A156e8E597C64d4a12d62f20a0d2ff839dD5 xDAI Asset Proxy contract Swapper 0xb68C0D092842a4a0272867D89245FCD7e7fcA3Eb xDAI Swapper contract Wrapper 0xD5d63Dce45E0275Ca76a8b2e9BD8C11679A57D0D WrapperV1 that takes transferred asset as fee WrapperV2 0x74A7f2A3aFa8B0CB577985663B5811901A860619 WrapperV2 that takes native asset as fee Back to top Avalanche Type Contract Desc CCMP 0xE3D0FB6E3cB5DA61EB18b06D035052441009d1E6 Avalanche Cross Chain Manager Proxy contract CCM 0x2aA63cd0b28FB4C31fA8e4E95Ec11815Be07b9Ac Avalanche Cross Chain Manager contract CCD 0x6c2A37Cf23E21EF3cFC45FdE2C0E1d3a9e7365f9 Avalanche Cross Chain Data contract Lock Proxy 0xd3b90E2603D265Bf46dBC788059AC12D52B6AC57 Avalanche Asset Proxy contract Swapper 0xb68C0D092842a4a0272867D89245FCD7e7fcA3Eb Avalanche Swapper contract Wrapper 0x287Bd66753f0cA8e9C2171D782DF39e4C28cfd65 WrapperV1 that takes transferred asset as fee WrapperV2 0xf06587dE89e289Ce480CDf21109A14547eb33A0d WrapperV2 that takes native asset as fee Back to top Fantom Type Contract Desc CCMP 0xE3D0FB6E3cB5DA61EB18b06D035052441009d1E6 Fantom Cross Chain Manager Proxy contract CCM 0x2aA63cd0b28FB4C31fA8e4E95Ec11815Be07b9Ac Fantom Cross Chain Manager contract CCD 0x6c2A37Cf23E21EF3cFC45FdE2C0E1d3a9e7365f9 Fantom Cross Chain Data contract Lock Proxy 0xd3b90E2603D265Bf46dBC788059AC12D52B6AC57 Fantom Asset Proxy contract Swapper 0xb68C0D092842a4a0272867D89245FCD7e7fcA3Eb Fantom Swapper contract Wrapper 0x287Bd66753f0cA8e9C2171D782DF39e4C28cfd65 WrapperV1 that takes transferred asset as fee WrapperV2 0xf06587dE89e289Ce480CDf21109A14547eb33A0d WrapperV2 that takes native asset as fee Back to top Optimistic Type Contract Desc CCMP 0xE3D0FB6E3cB5DA61EB18b06D035052441009d1E6 Optimistic Cross Chain Manager Proxy contract CCM 0x2aA63cd0b28FB4C31fA8e4E95Ec11815Be07b9Ac Optimistic Cross Chain Manager contract CCD 0x6c2A37Cf23E21EF3cFC45FdE2C0E1d3a9e7365f9 Optimistic Cross Chain Data contract Lock Proxy 0xd3b90E2603D265Bf46dBC788059AC12D52B6AC57 Optimistic Asset Proxy contract Swapper 0xD24BEcEdFCE7f95693Fa3938eaC6dd66725B4Bbf Optimistic Swapper contract Wrapper 0x287Bd66753f0cA8e9C2171D782DF39e4C28cfd65 WrapperV1 that takes transferred asset as fee WrapperV2 0xf06587dE89e289Ce480CDf21109A14547eb33A0d WrapperV2 that takes native asset as fee Back to top Metis Type Contract Desc CCMP 0xE3D0FB6E3cB5DA61EB18b06D035052441009d1E6 Metis Cross Chain Manager Proxy contract CCM 0x2aA63cd0b28FB4C31fA8e4E95Ec11815Be07b9Ac Metis Cross Chain Manager contract CCD 0x6c2A37Cf23E21EF3cFC45FdE2C0E1d3a9e7365f9 Metis Cross Chain Data contract Lock Proxy 0xeFB5a01Ed9f3E94B646233FB68537C5Cb45e301D Metis Asset Proxy contract Lock Proxy-PIP4 0xbE46E4c47958A79E7F789ea94C5D8071a0DeE31e Metis Asset Proxy contract WrapperV3 0xFbFDfc95B8EAe4719Ae7D7b94e6F7aCC2DC2e0D7 WrapperV3 that takes native asset as fee Back to top Router And Chain ID Type Router Number Chain ID Bitcoin 1 1 Ethereum 2 2 Ontology 3 3 Neo Legacy 4 4 Switcheo 5 5 BSC 6 6 Heco 7 7 Palette 8 8 Zilliqa 17 18 Curve 10 10 OKExChain 12 12 Neo N3 14 14 Heimdall 15 15 Polygon 16 17 Arbitrum 0 19 xDAI 0 20 Avalanche 0 21 Fantom 0 22 Optimistic 0 23 Metis 0 24 Back to top Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-21 10:44:47 "},"Core_Smart_Contract/Contract/TestNet.html":{"url":"Core_Smart_Contract/Contract/TestNet.html","title":"TestNet","keywords":"","body":" MainNet | TestNet | DevNet Here are cross chain contracts ONLY working in TESTNET mode, which are used to bind asset mapping in different chains. It refers to that the asset is mapping if the name ends with (s). Contract Index (Chain-Chain ID) Bitcoin-1 Ethereum-2 Ontology-3 Neo N2-5 Switcheo- BSC-79 HECO-7 Palette-107 OK-200 Curve-82 Neo N3-88 Polygon-202 Zilliqa-111 Arbitrum-205 xDAI-206 Avalanche-209 Fantom-208 Optimistic-207 Metis-300 Goerli-502 Rinkeby-402 Kovan-302 Pixie-316 Boba-400 Quick Index Router And Chain ID Ethereum Type Contract Desc CCMP 0xb600c8a2e8852832B75DB9Da1A3A1c173eAb28d8 Cross Chain Manager Proxy contract CCD 0xA38366d552672556CE82426Da5031E2Ae0598dcD Cross Chain Data contract CCM 0xf989E80AAd477cB6059f366C0170a498909C4a55 Cross Chain Manager contract Lock Proxy 0xD8aE73e06552E270340b63A8bcAbf9277a1aac99 Asset Proxy contract Wrapper 0xDc37471Af6a8aB7f45F444c5a3Ef4758281bE32C WrapperV1 that takes transferred asset as fee NFT Lock Proxy 0x9bEF1AE7304D3d2F344ea00e796ADa18cE1beb03 NFT lock proxy contract NFT Wrapper 0x940300dc3Fc26e3A330a300be766184C0b5Fe019 NFT Wrapper contract NFT Query 0x500674D603331C43ed2288834BAb284BF65fc076 NFT profile query contract NFT SEASCAPE 0x3680fb34F55030326659cd9AaEc522B6E355bdB6 SEASCAPE NFT contracct hash Back to top BSC Type Contract Desc CCMP 0x441C035446c947a97bD36b425B67907244576990 Cross Chain Manager Proxy contract CCD 0xE815E5B52A659d78c91B747f7A3b358cc4F04794 Cross Chain Data contract CCM 0x906bC93FF690d6D3D2C4E7A7dfA4dEbdEF2cD7CA Cross Chain Manager contract Lock Proxy 0x097Ae585BfEf78DDC8E266ABCb840dAF7265130c Asset Proxy contract Lock Proxy-PIP4 0xB4004B93f1ce1E63131413cA201D35D1F3f40e5D Asset Proxy with LP contract Wrapper 0x9f9F15CC407F7b26f55D71D43f993580a9107007 WrapperV1 that takes transferred asset as fee WrapperV3 0xfb717F8d478156fE7428369075bB2FaB4Ea659B5 WrapperV3 that takes native asset as fee NFT Lock Proxy 0x9bEF1AE7304D3d2F344ea00e796ADa18cE1beb03 NFT Lock Proxy contract NFT Wrapper 0x61E289D43C1FEA7598786557A2F309979ad144D3 NFT Wrapper contract NFT Query 0xAB3e1F13127bE931A71Fdc8940bd31506EFC6A70 NFT profile query contract NFT SEASCAPE 0x66638F4970C2ae63773946906922c07a583b6069 The seascape NFT contract NFT Nobel Boss 0x301294a9c7c218d439edd6d5ab16f9663fc10f3e NFT Nobel Boss Mint contract Back to top OK Type Contract Desc CCMP 0x38917884b397447227fb45cbA0342F1bFf7A3470 Cross Chain Manager Proxy contract CCD 0xd1Acc7bc3BDA9a63eEF89357a6f4c705ee874f44 Cross Chain Data contract CCM 0x296f7f9f0e65152965e9BE12b349c14c7cE8eE85 Cross Chain Manager contract Lock Proxy 0x74cE7D56cd1b5AEe9A3345A490b5Ed768134C7D4 Asset Proxy contract Back to top HECO Type Contract Desc CCMP 0xc5757b5d22984E534004cC7Fb1D59eD14EC510a5 Cross Chain Manager Proxy contract CCD 0x709D63f3d1a46B89cE4F6a61C8fb16aB29fD26F8 Cross Chain Data contract CCM 0x40039148ce624B560e5F5c095DdA90fc13442Cf8 Cross Chain Manager contract Lock Proxy 0x4a76E52600C6285029c8f7c52183cf86282cA5b8 Asset Proxy contract Wrapper 0xCC8407Ee04AaC2AdC0E6A55E7E97176C701146cd Wrapper contract NFT Lock Proxy 0x25BB8E9C0Cc03B30d09769735208a47d389Ff36c NFT Lock Proxy contract NFT Wrapper 0xbaBaAF5CF7f63437755aAAFE7a4106463c5cD540 NFT Wrapper contract NFT Query 0xE1488842b15E0f084b254588f46e4C570065d6A0 NFT profile query contract NFT SEASCAPE 0xF9Dd424e64E9264632a564FBDcC87Ba8eA40B5Ba SEASCAPE NFT contract Back to top Ontology Don't conduct data transmission on Ontology network during its testnet upgrading. Type Contract Desc Wrapper B:a5c101afa9e04e9dd2c912983795005a49e02efa L: fa2ee0495a0095379812c9d29d4ee0a9af01c1a5 WrapperV1 that takes transferred asset as fee Lock Proxy B: 33c439c502cb4b6ac5a1e8057a65fe1fa7c300e2 L: e200c3a71ffe657a05e8a1c56a4bcb02c539c433 Asset Proxy contract Back to top Note B means big-endian, we can search the contract transaction history in corresponding explorer. L means little-endian, we usually use it as the asset hash input when we do binding asset hash operation. Back to top Neo N2 Type Contract Desc Wrapper B: 58659ce8f3efb1c06e4e26a9850583e39aad4f0f L: 0x0f4fad9ae3830585a9264e6ec0b1eff3e89c6558 WrapperV1 that takes transferred asset as fee Nep5Proxy B: 4f5f702b3f459f222d371052940bb9ce2d86d2ed L: 0xedd2862dceb90b945210372d229f453f2b705f4f Asset Proxy contract CCM B: 07946635d87e4120164835391e33a114135b69e1 L: 0xe1695b1314a1331e3935481620417ed835669407 Cross Chain Manager contract Back to top Neo N3 Type Contract Desc Wrapper WrapperV1 that takes transferred asset as fee Nep17Proxy B: 42e54382e86dcdca09e0da8bb67e2fac4d498744 L: 0x4487494dac2f7eb68bdae009cacd6de88243e542 Asset Proxy contract CCM B: 2a774fa0404f020254f6db20616cf13adc448d61 L: 0x618d44dc3af16c6120dbf65402024f40a04f772a Cross Chain Manager contract NFT Lock Proxy B: 1a9e25a2484e92fbca10379984db16221003cd7a L: 0x7acd03102216db84993710cafb924e48a2259e1a NFT Lock Proxy contract Back to top Cosmos Type Denom (coin name) Asset/Contract Desc Lock Proxy f71b55ef55cedc91fd007f7a9ba386ec978f3aa8 Asset Proxy contract Back to top Polygon Type Contract Desc CCMP 0x15D3f62822a446b8C5fDBBef157f0b82b05c29Ab Cross Chain Manager Proxy contract CCD 0xd097cf11c0215563AaAE2d3bb49366C59FFFa144 Cross Chain Data contract CCM 0xe6d97637EFb55d8c81154E29aC343Bc447F80c19 Cross Chain Manager contract Lock Proxy 0x4e5eF0CA5A94b169Fb010fb40DBFD57c4830f446 Asset Proxy contract Wrapper 0xD5d63Dce45E0275Ca76a8b2e9BD8C11679A57D0D WrapperV1 that takes transferred asset as fee Swapper 0x1B0C55be400e2a7D924032B257Fbc75Bbfd256E7 Curve entrance for auto cross chain tx with fee NFT Lock Proxy 0x761fb099d021cf55ffe65f9bedd3e2bab52abccc NFT Lock Proxy contract NFT Wrapper 0xea5b2a0cf4ca9bd5c72ea1fbee1ffe420e57f692 NFT Wrapper contract NFT Query 0x13227576c94119755bbad5bf01d8ac332f80e8ad NFT profile query contract NFT Nobel Boss 0xd0609f06ffa034a525d31fdc1a4ba94a457f4620 NFT Nobel Boss Mint contract Back to top Palette Type Contract Desc CCMP 0x309064768EBD4EeF8ce073888e2f1C7e1CCCa191 Cross Chain Manager Proxy contract CCD 0x17d37a71986b7592dF8BAD1a9F0FB8Da9792d8D3 Cross Chain Data contract CCM 0xB64EE4b7cf935C51233b6ED9b0732D3Bd26E3442 Cross Chain Manager contract PLT Wrapper 0x2D44Db62D82EE13ff7DD02C03CA37b240213175C PLT Wrapper contract NFT Wrapper 0xFeEbBc92365a203a2FDCc4B1bBDAA2489A9bb6Ac NFT Wrapper contract NFT Lock Proxy 0x6e5fB68D6B705A567d75135169cF69574225eBe6 NFT Lock Proxy contract NFT Query 0x34B5B0cC2b57d96d3930Ddc66084029170fE6BFD NFT profile query contract Back to top Zilliqa Type Contract Desc CCMP 0x6b95e35a3355df6d841127349f243ef4f017eaf2 Cross Chain Manager Proxy contract CCM 0x720a3fb587b670de99d94925b6f99c9a63d462c1 Cross Chain Manager contract Lock Proxy 0xa5a43eecd29534edf80792a9889f52c77455245d Asset Proxy contract Back to top Arbitrum Type Contract Desc CCMP 0xeE96Aa05b320a570C489aBd5EEc546AE4Fb58Eb7 Cross Chain Manager Proxy contract CCD 0x71c2003f90bA0D2ce8a79DE9a70E7dD41BBfB983 Cross Chain Data contract CCM 0x3A77dB10eAa7436e608a99643Ab2bEB2E901C72C Cross Chain Manager contract Lock Proxy 0x97f72bA888A26A0F98C67cf15d781dDBFE64B990 Asset Proxy contract Wrapper 0x27eb74B4Db37517F1dC6dE67364e19782624402F WrapperV1 that takes transferred asset as fee Back to top xDAI Type Contract Desc CCMP 0x3E5ceC313CECaa37319e0F2C949656441103C429 Cross Chain Manager Proxy contract CCD 0xAefD220aE393144dcb5EFD6Ab55ABDf6a3d0444d Cross Chain Data contract CCM 0xF87527a74215777391fE4AfD082FeeED3E5A0ca5 Cross Chain Manager contract Lock Proxy 0x52B3048eeF2E53bAF430B0bA4752999F244d1709 Asset Proxy contract Wrapper 0xa7eDA65F94A2a334a0de42d479585b65D27b2249 WrapperV1 that takes transferred asset as fee Back to top Optimistic Type Contract Desc CCMP 0x0ca3f95c8f66C7B178414CCFd7a508d349b9f794 Cross Chain Manager Proxy contract CCD 0xbA6F835ECAE18f5Fc5eBc074e5A0B94422a13126 Cross Chain Data contract CCM 0xC8042579D6b60E0e35161F228827E3Fa0F51d5B6 Cross Chain Manager contract Lock Proxy 0x8a85143cA6ec1e181C3A5Ae4042ca999bFbF571B Asset Proxy contract Wrapper 0xE324EF8cd52833DD117e8ca87b483E78b30C3696 WrapperV1 that takes transferred asset as fee Back to top Fantom Type Contract Desc CCMP 0x74D67A4EFbA6Dbbb14DC574b6Db4F11f6b1C5af8 Cross Chain Manager Proxy contract CCD 0x4Bf7b284De2999628CBBEf6fE9F74f8B8E5eBF16 Cross Chain Data contract CCM 0x1C84D74084c3C3301BE4777A568D78211189c871 Cross Chain Manager contract Lock Proxy 0x4a76E52600C6285029c8f7c52183cf86282cA5b8 Asset Proxy contract Wrapper 0xFAddf0cfb08F92779560db57BE6b2C7303aaD266 WrapperV1 that takes transferred asset as fee Back to top Avalanche Type Contract Desc CCMP 0xcdd05Ebaa1FA06a5cE9eB67663aE9Ec78B37bd5B Cross Chain Manager Proxy contract CCD 0x4d8BC48087b994AA419d4679069584a7C92586A8 Cross Chain Data contract CCM 0xf37D8C2d072b74d6532541B70319ef08f9F6a4a8 Cross Chain Manager contract Lock Proxy 0x80a53FD352597AbA3dD52c722119865a8ed82632 Asset Proxy contract Wrapper 0xac0a6759696569B3729177ba6844D41FF6D57844 WrapperV1 that takes transferred asset as fee Back to top Metis Type Contract Desc CCMP 0xD5a240f7F755bCa2aE992E807b06d24eB6DF7C12 Cross Chain Manager Proxy contract CCD 0x30e6ec356ceF1cfe3c7e14392EA08448382327bD Cross Chain Data contract CCM 0xd6fc5374649cea121395a4860FdB33F21783c4Af Cross Chain Manager contract Lock Proxy 0x0AF53d318De279C8e67FcC6914acF387CFaA8B7E Asset Proxy contract Lock Proxy-PIP4 0xe6E89cde11B89D940D25c35eaec7aCB489D29820 Asset Proxy with LP contract Wrapper 0xc2d365475EEf3ec83e59D1BcDF3A291D7B23Ba99 WrapperV1 that takes transferred asset as fee WrapperV3 0xA09E4d0406123d14CFB1d60D78C6Dc386b7de7F9 WrapperV3 that takes native asset as fee WrapperV2 0xb0354F5383839e163438Aa53dd58E5e70a548F2F WrapperV2 that takes native asset as fee Back to top Goerli Type Contract Desc CCMP 0xC8042579D6b60E0e35161F228827E3Fa0F51d5B6 Cross Chain Manager Proxy contract CCD 0x10BCC4B6C2555fF48540571ebe5aBa6D32915250 Cross Chain Data contract CCM 0xbA6F835ECAE18f5Fc5eBc074e5A0B94422a13126 Cross Chain Manager contract Lock Proxy 0x509fB7A017e33f18101dDC0d28Ac06aEaf6Edb4B Asset Proxy contract WrapperV2 0xA058FC5427d3E634698d1185C1BA01ADAf998E14 WrapperV2 that takes native asset as fee Back to top Rinkeby Type Contract Desc CCMP 0x0ca3f95c8f66C7B178414CCFd7a508d349b9f794 Cross Chain Manager Proxy contract CCD 0xbA6F835ECAE18f5Fc5eBc074e5A0B94422a13126 Cross Chain Data contract CCM 0xC8042579D6b60E0e35161F228827E3Fa0F51d5B6 Cross Chain Manager contract Lock Proxy 0x8a85143cA6ec1e181C3A5Ae4042ca999bFbF571B Asset Proxy contract Lock Proxy-PIP4 0x30e6ec356ceF1cfe3c7e14392EA08448382327bD Asset Proxy with LP contract WrappeV2 0xE324EF8cd52833DD117e8ca87b483E78b30C3696 WrapperV2 that takes native asset as fee WrapperV3 0xD5a240f7F755bCa2aE992E807b06d24eB6DF7C12 WrapperV3 that takes native asset as fee NFT Lock Proxy 0x9bEF1AE7304D3d2F344ea00e796ADa18cE1beb03 NFT Lock Proxy contract NFT Wrapper 0x25BB8E9C0Cc03B30d09769735208a47d389Ff36c NFT Wrapper contract NFT Query 0x6fd13dd4181dDb0f7463e19caC659FD3e9FB8a82 NFT profile query contract Back to top Kovan Type Contract Desc CCMP 0x8a85143cA6ec1e181C3A5Ae4042ca999bFbF571B Cross Chain Manager Proxy contract CCD 0x7D87b4C81B9efE1783E0524a6f475F9C526641C2 Cross Chain Data contract CCM 0x509fB7A017e33f18101dDC0d28Ac06aEaf6Edb4B Cross Chain Manager contract Lock Proxy 0x95a10b809c9Cfd51A46652C785ac73d7269834b9 Asset Proxy contract WrapperV2 0xa2d97d1A123c6bD39AFD97F696B937fAcb024313 WrapperV2 that takes native asset as fee Back to top Pixie Type Contract Desc CCMP 0x8F967507Ae66ad78c12478E10cA07c9104eb24A7 Cross Chain Manager Proxy contract CCD 0xF9Dd424e64E9264632a564FBDcC87Ba8eA40B5Ba Cross Chain Data contract CCM 0x2E830E0cf3dc8643B497F88C07c8A72EFE24B11f Cross Chain Manager contract Lock Proxy 0x46Fc99509c4Aab0c958B8b2175edAa9C4963Ac09 Asset Proxy contract WrapperV2 0xE7Db150e4095Cbb35914b5dC980906C77B5990d2 WrapperV2 that takes native asset as fee NFT Proxy 0xD54a267B2c983d883D39248Dd7002dc7405559E0 NFT Proxy contract NFT Query 0xbaBaAF5CF7f63437755aAAFE7a4106463c5cD540 NFT profile query contract NFT Wrapper 0x06e3d8Eeb9DC4732e474c26674e08213c6e11921 NFT Wrapper contract Back to top Boba Type Contract Desc CCMP 0x720aF2de5eA84b78AAC7BDFA812B47e41516D59c Cross Chain Manager Proxy contract CCD 0x55a59c57a133d1c999b3Eaf5B16ad5c1F2e365c8 Cross Chain Data contract CCM 0xa65bD4431C38A4dD9c92ebE60dE3cb8C252c04E5 Cross Chain Manager contract Lock Proxy-PIP4 0x46Fc99509c4Aab0c958B8b2175edAa9C4963Ac09 Asset Proxy with LP contract WrapperV3 0xF87527a74215777391fE4AfD082FeeED3E5A0ca5 WrapperV3 that takes native asset as fee Back to top Router And Chain ID Type Router Number Chain ID Bitcoin 1 1 Ethereum 2 2 Ontology 3 3 NEO(N2) 4 5 Switcheo 5 - BSC 6 79 HECO 7 7 Palette 8 107 Zilliqa 111 111 OK 12 200 Curve 10 82 Heimdall 15 201 Polygon 16 202 NEO(N3) 88 88 Arbitrum 0 205 xDAI 0 206 Optimistic 0 207 Fantom 0 208 Avalanche 0 209 Metis 0 300 Goerli 0 502 Rinkeby 0 402 Kovan 0 302 Pixie 0 316 Boba 0 400 Back to top Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-21 10:44:47 "},"Core_Smart_Contract/Contract/DevNet.html":{"url":"Core_Smart_Contract/Contract/DevNet.html","title":"DevNet","keywords":"","body":" MainNet | TestNet | DevNet Here are cross chain contracts ONLY working in DevNet mode, which are used to bind asset mapping in different chains. It refers to that the asset is mapping if the name ends with (s). Contract Index (Chain-Chain ID) Bitcoin-1 Ethereum-2 Ontology-3 Neo Legacy-217 Switcheo-182 Neo N3-220 Pixie-321 Cosmos-gaia-8 Quick Index Router And Chain ID Btc BTCx Redeem Script: 522103c4564b837674de2482961a8d5f2a24a7e11e8a97aac5e92ac2e64500219144512102ccc07d3df7da58bb6fa5cfe5d7be415ff9463171b2600c93c080fcd0d49576a721036ec6299c1b14e57b45f1ad85eecbc48ad5447a05158a1bfb2ffb689ad69490d353ae BTCx Redeem Key: c737784e5fdae8860fb461d4d30ffd0b34701d5aBack to top Ethereum Type Contract Desc CCMP 0x7087E66D6874899A331b926C261fa5059328d95F Cross Chain Manager Proxy contract Lock Proxy 0x46DE64740cf839374afB264970f8D437732649cA Asset Proxy contract Back to top Ontology Type Contract Desc Lock Proxy B: ebad45b887c6bf7cc4c1df8f72da156bc91b04b7 L: b7041bc96b15da728fdfc1c47cbfc687b845adeb Asset Proxy contract Back to top Neo Legacy Type Contract Desc CCM B: 0x3135a1a4668688a3e15b004af3a718f2d67141ca L: ca4171d6f218a7f34a005be1a3888666a4a13531 Cross Chain Manager contract Lock Proxy B: 0x3fef7ac6598ad83f5e4d4338e65530eba2173294 L: 943217a2eb3055e638434d5e3fd88a59c67aef3f Asset Proxy contract Receiver:A: AZXRTygHgRbPu9o16K6en4BaZD11tXCmN1 B: 0x4fd83a49df40c0a7de2671da20c2a8dfe495b6c2 L: c2b695e4dfa8c220da7126dea7c040df493ad84f Back to top Neo N3 Type Contract Desc CCM B: 0x7c842f3900ceba5bcdeeeec05c9b41ba63ad6cd2 L: d26cad63ba419b5cc0eeeecd5bbace00392f847c Cross Chain Manager contract Lock Proxy B: 0x5376f41082a84fb000c944b6d44ba85b14e20fe5 L: e50fe2145ba84bd4b644c900b04fa88210f47653 Asset Proxy contract Receiver: A: NLKpYEDmyGMWQVeqcoyZr9Lyo8P5Mrozba B: 0x67ce818168a75d3bedb7d295bf11c060d1c38204 L: 0482c3d160c011bf95d2b7ed3b5da7688181ce67 Back to top Note B means big-endian, we can search the contract transaction history in corresponding explorer. L means little-endian, we usually use it as the asset hash input when we do binding asset hash operation. Back to top Cosmos-Gaia Type Denom (coin name) Asset/Contract Desc Lock Proxy f71b55ef55cedc91fd007f7a9ba386ec978f3aa8 Asset Proxy contract Back to top Pixie Type Contract Desc CCD 0x25BB8E9C0Cc03B30d09769735208a47d389Ff36c Cross Chain Data contract CCM 0x6fd13dd4181dDb0f7463e19caC659FD3e9FB8a82 Cross Chain Manager contract CCMP 0x9bEF1AE7304D3d2F344ea00e796ADa18cE1beb03 Cross Chain Manager Proxy contract Lock Proxy 0xa85c9FC8F2c9060d674E0CA97F703a0A30619305 Asset Proxy contract WrapperV2 0x455B51D882571E244d03668f1a458ca74E70d196 WrapperV2 that takes native asset as fee NFT Lock Proxy 0x6Bc728a0ce7e189CBfb8AD932fb57928106D2674 NFT Lock Proxy contract NFT Wrapper 0x3237b7BC8283B4E07bAC017EAe52eBC34B278cE9 NFT Wrapper contract NFT Query 0x35EFCE8D79D6Cae30B38F6dAC3fc55C62c146b4c NFT profile query contract pixie test net rpc: https://http-testnet.chain.pixie.xyz pixie test net explorer: https://scan-testnet.chain.pixie.xyz/ Back to top Router And Chain ID Type Router Number Chain ID Bitcoin 1 1 Ethereum 2 2 Ontology 3 3 NEO Legacy 217 217 NEO N3 220 220 Cosmos-gaia 5 8 Switcheo 5 182 Pixie 19 321 Back to top Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-21 10:44:47 "},"Core_Smart_Contract/Nodes/Nodes.html":{"url":"Core_Smart_Contract/Nodes/Nodes.html","title":"Nodes","keywords":"","body":" Decentralized Application MainNet Nodes | Decentralized Application TestNet Nodes Decentralized Application MainNet Nodes Chain IP Rpc Port Poly http://seed1.poly.network 20336 Neo Legacy http://seed9.ngd.network 11332 Neo N3 http://seed5.neo.org 10332 Back to top Decentralized Application TestNet Nodes Chain IP Rpc Port Poly http://beta1.poly.network 20336 Neo http://seed9.ngd.network 20332 Back to top Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-21 10:49:42 "},"GLOSSARY.html":{"url":"GLOSSARY.html","title":"Glossary","keywords":"","body":"Relayer A cross-chain information porter performs some of the most critical operations within the cross-chain. It acts as the medium of interaction between the side chain and the outside world. Each chain in the cross-chain ecosystem has a relayer associated with it. Relayer monitors its corresponding chain network for cross-chain transactions and forwards the respective block headers to the poly chain if detected, gaining available incentives in the process. At the same time, it also monitors for cross-chain transactions taking place on the poly chain and transfers them to the respective side chain. Side Chain A chain that is interested in joining the poly cross-chain ecosystem Source Chain A public chain corresponds to the target chain where a particular asset firstly appears. Target Chain A public chain corresponds to the source chain on which we want to cross an asset and issue a new token. For the ether asset, Ethereum is the source chain. When we want to issue a new OEP4 token in The Ontology network represents the ether, and the Ontology chain will be the target chain for the ether asset. Vice versa, For the ONT token, the Ontology chain is the source chain. When we want to issue a new ERC20 token in the Ethereum chain, Ethereum would be the target chain for the Ont network. Poly Chain The relay chain in the cross-chain ecosystem. One of the crucial components of the cross-chain ecosystem. Each type of node is deployed and maintained by other individuals or organizations and has its unique governance and trust mechanism. The poly chain is responsible for connecting them, standardizing cross-chain data flow and interfaces, verifying the legitimacy of cross-chain data, etc. Canonical Block A block is included in the primary blockchain and is directly or indirectly referenced by future blocks. Blocks that are not canonical may have been valid but were discarded in favor of the canonical block. Cross Chain Council A Council formed by poly consensus nodes. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-21 10:44:47 "},"FAQ/template.html":{"url":"FAQ/template.html","title":"FAQ","keywords":"","body":"FAQ Though not exhaustive, these FAQs will help you get started and troubleshoot some of the most common user problems when using Poly Bridge. Stay Tuned with Us: Official site：https://www.poly.network/ Poly Bridge: https://bridge.poly.network Twitter: https://twitter.com/PolyNetwork2 Medium: https://medium.com/@polynetwork Telegram: https://t.me/polynetworkgroup Discord: https://discord.gg/xXxJa3sm Github: https://github.com/polynetwork User Guides and Tutorials: https://medium.com/poly-network/tagged/tutorial About Poly Network Ecosystem Q1: What is Poly Network? How does Poly Network work? A:facts Q2: How many kinds of chains does Poly Network support? A: Q3: How to integrate the chain to Poly Network ecosystem? A: Q4: How to establish the product on Poly Network ecosystem? A: - subQ4: How to interact with Poly Network protocol? - subA4: Q5: What features Poly Network can provide? A: Q6: Is Poly Network a kind of open source? A: About Poly Bridge When you first meet Poly Bridge, you may concern: Q: What is Poly Bridge? What functions does it provide? Where is the website? A: Poly Bridge is a bridge through which you can transfer your asset (include tokens and NFTs) between different chains easily and quickly. If you are a developer, you may concern: Q1: What kind of pairs are available on the Poly Bridge? A: Here is an interface (Link) provided for querying pairs on Poly Bridge Q2: How to integrate token onto Poly Bridge? A: Here is a tutorial (Link) instructing developers to integrate token onto Poly Bridge. Q3: Any kind... A: Q4: Where can I find the contract? A: Here is an appendix (Link) that includes basic contracts and some business contracts deployed and used by Poly Network, please go to check it. If you are a user, you may concern: Q1: How to transfer my assets between two chains through Poly Bridge? A: Please refer to the manual (Link) below. Q2: How much fee does Poly Bridge charge per transaction? A: It depends on the network you are sending from and to. The fee paid via Poly Bridge is for covering gas fee charged by target chain. No extra fee will be charged by Poly Bridge. Q3: How long does it take per transaction? A: Average estimated time of arrival is 1-10 min. Irresistible factors such as network congestion might delay the transaction. If your transaction hasn’t been completed for a long time, please refer to Q7. Q4: Where can I find my previous transaction? A: You can check your previous transaction in \"History\". Q5: Is the bridge rate 1:1? A: Normally yes. Except deflationary tokens. Q6：When I encounter an error in the wallet, what can I do? A: - Firstly, make sure you have approved enough amount for Poly Bridge contract to use the token. - Then, make sure you have sufficient native tokens to pay the gas fee on the source chain. Please be noted that the amount of native tokens should be excluded from the fee you paid for Poly Bridge and the amount you plan to transfer. For example, if you want to transfer $Metis from Andromeda to BSC, you have to reserve two portions of tokens: one for target chain gas fee, the other for source chain gas fee. The rest are tokens you can transfer. - Besides, if you encounter other errors, please contact Poly Network team. Q7: I have waited a long time and still didn't receive my asset, what can I do? A: Please check which step your transaction has reached. Solutions vary from different steps, see below: - The transaction hasn't been completed on src chain：For safety reason, Poly Bridge will not confirm your transaction immediately until subsequent blocks have been confirmed (the number of subsequent blocks depending on different chains), please wait for block confirmation. - The transaction has been completed on src chain, but not completed in Poly: if the transaction has been stuck in this step for over 5 min, please do not hesitate to contact the Poly Network Team. - The transaction hasn't been completed on the target chain: it’s perhaps down to the transaction congestion of target chain, please wait for a while or refer to the accelerated transaction tutorial. If the accelerated tutorial doesn't work, please contact the Poly Network team. Q8: How can I check the status of my transaction? A: Click “History” in the Poly Bridge to find the transaction and then click “Status” to check the progress. Q9: Why does it show \"sufficient liquidity\" on the target chain before sending a transaction and \"insufficient liquidity\" on the target chain after sending a transaction? A: - Firstly, the liquidity shown on Poly Bridge is shared for all users. If there are several users making large transactions simultaneously, insufficient liquidity will appear. - It happens when the amount you are transferring is close to the max available amount. Under this occasion, Poly Network will contact the relevant project to add liquidity as soon as possible. Please be patient. Q10: Can I use Poly Bridge by mobile phone? A: Of course, here is a manual (Link) for mobile users. Q11: When encountering an “unknown wallet error”, what can I do? -A: Please check whether the currently connected network is stable, which can be observed by switching nodes. Q12: I encountered an error and submitted an accelerated transaction…what’s next? A: - Firstly, please do not submit accelerated transactions when you encounter an error. This error means the transaction hasn't been completed on the target chain. - Then turn back to your wallet to check the balance. If you have not received it, please contact us. Q13: Is Poly Network related to polygon, polymath, or Poly Chain capital? A: Q14: If my transaction is stuck on the bridge, can I cancel the transfer and receive a refund instead? A: Q15: When migrating funds to or from ETH, why is the fee so high? A: Q16: The transaction says that it's confirmed in my history, but why aren't the tokens showing in my Metamask? A: You may have to manually add that specific asset to your Metamask. This can be achieved by selecting the \"import tokens\" option in your Metamask wallet and then copy and paste the token contract address for the asset you wish to add. Some critical concerned: Q1: Are Poly Bridge's smart contracts audited? A: Q2: Is the bridge decentralized? A: Q3: Who or where can I ask for help when I crush a problem? A: Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-21 10:44:47 "}}