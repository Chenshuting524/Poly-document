{"./":{"url":"./","title":"Introduction","keywords":"","body":"SummaryIntroductionDevelopmentGlossaryFAQSummary Introduction Development Joing the Cross Chain Ecosystem Two Scenarios Essential Elements for Header Sync Common Steps for Header Sync Develop Guideline for Header Sync Calling the Cross Chain Smart Contract Cross Chain Interaction Between Chains Interfaces Offered by Cross Chain Manager Example of Business Logic Smart Contract Integrating New Tokens Chapter1 Chapter2 Chapter3 Integrating Poly Bridge to Websites Chapter1 Chapter2 Chapter3 Glossary Glossary FAQ Default header1 Copyright © 2021 PolyNetwork all right reserved，powered by GitbookLast modification date： 2021-12-29 16:56:14 "},"add_chain/readme.html":{"url":"add_chain/readme.html","title":"Joing the Cross Chain Ecosystem","keywords":"","body":"How to Join the Cross-Chain EcosystemHow to Join the Cross-Chain Ecosystem The poly cross-chain ecosystem provides a platform for various chains to interact and transfer data and conduct cross-chain transactions. Any chain can freely join the ecosystem. However, the chains that support smart contracts can interact and share all kinds of information between chains, while the chains that do not support smart contracts are limited to cross-chain asset transfer. There are two scenarios for adding a new chain to the poly cross-chain ecosystem: Header Sync and Consensus Vote. While Header Sync is more trustworthy and scalable, Consensus Vote is a backup plan when Header Sync is not applicable. It is crucial to know whether a chain can join poly using Header Sync, and the core is whether this chain has a mechanism for nodes like ethereum light client to verify transactions using block header information only. A more detailed explanation is in the first chapter of this branch. This Branch is intended for developers who want to help add a new chain to the poly cross-chain ecosystem, mainly for Header Sync Scenario because the Consensus Vote hardly needs any development. Here is the outline that will be introduced: The overview of two scenarios for handling cross-chain events The features and attributes required for adding a new side chain to the poly cross-chain ecosystem in header sync scenario The technical flow for adding a new side chain to the poly cross-chain ecosystem in header sync scenario The interface method needs to be implemented in header sync scenario Copyright © 2021 PolyNetwork all right reserved，powered by GitbookLast modification date： 2021-12-29 14:38:21 "},"add_chain/scenario.html":{"url":"add_chain/scenario.html","title":"Two Scenarios","keywords":"","body":"Poly Cross-Chain Ecosystem ScenarioBlock Header Synchronization ScenarioConsensus Vote ScenarioPoly Cross-Chain Ecosystem Scenario Poly has two scenarios for verifying the transaction block and the cross-chain transaction information it carries: Header Sync: Verify the block header based on the critical blockchain data such as validator set and their commitment, signature, mining difficulties. Verify the cross-chain transaction based on the corresponding Merkle proof of cross-chain events and transactions Consensus vote： Every Poly node act as a full node of the target blockchain, validating the blocks and cross-chain transactions following the rules of the side chain. The success of the cross-chain request depends on the consensus vote result of poly nodes Consensus Vote is not suggested for security and scalability reasons unless Header Sync can not be achieved. Here are two factors that determine the cross-chain event can be verified based on Header Sync: The blockchain support Merkle proof for verifying transactions, whether it has Merkle tree generation and verification method for the ledger records or transactions. This allows the relay chain to determine the legitimacy of the transaction records. The block headers have the validator set and their commitment or signature for verification. In other words, relayers who act as light clients can obtain the validator sets and their commitment or signature from only the block header information and ensure the legitimacy of the block headers. Block Header Synchronization Scenario The general steps for joining poly cross-chain ecosystem using header sync scenario are as follows: Deploy Contract CCM/CCMP/CCD/LockProxy/Wrapper or develop a specific interface that has the same functionality as a contract, for more details, see Chapter \"Core Smart Contract List\"(Attach a Link to smartcontractList.MD) Register the chain, approve the registration by consensus vote. To update the registered chain information, the registered account needs to send an application to the relay chain when updating side chain information. An application needs to be approved by at least two-thirds of the current consensus nodes to carry out the update action successfully. Synchronize an initial block header of the side chain to poly chain, and synchronize an initial block header of poly chain to the side chain's ccm smart contract. Synchronize all the consequent blocks of the side chain to poly chain. Synchronize some of the valuable blocks of the relay chain to the ccm contract of the side chain. Verify cross-chain transaction using Merkle state root hash of block header and Merkle proof generated by source chain. The information requirement that needs to be clarified will be introduced in Essential Chain Elements. The module and interface method will be presented in detail in Guideline for Developers. Consensus Vote Scenario The general steps for joining poly cross-chain ecosystem using header sync scenario are as follows: Deploy Contract CCM/CCMP/CCD/LockProxy/Wrapper or develop a specific interface with the same functionality as a contract; for more details, see Chapter \"Core Smart Contract List\"(Attach a Link). Register the chain, approve the registration by consensus vote. To update the registered chain information, the registered account needs to send an application to the relay chain when updating side chain information. An application needs to be approved by at least two-thirds of the current consensus nodes to carry out the update action successfully. Every Poly node acts as a full node of the side chain, validating the blocks and cross-chain transactions following the side chain rules and submitting them to the poly chain. Verify cross-chain events and transactions using consensus vote of poly nodes. Please note that for chains that can only use Consensus Vote, only the code for holding a full blockchain node of the side chain is needed for joining the poly cross-chain ecosystem. Most of the remaining content of this branch is prepared for Header Sync. Copyright © 2021 PolyNetwork all right reserved，powered by GitbookLast modification date： 2021-12-28 16:10:43 "},"add_chain/elements.html":{"url":"add_chain/elements.html","title":"Essential Elements for Header Sync","keywords":"","body":"Essential Chain Elements Need to be ClarifiedIntroductionRequirement ListConsensus AlgorithmGenesis Block of the ChainBlock Header Structure and Verification MethodMerkle Tree Structure and Verification MethodEssential Chain Elements Need to be Clarified Introduction Before starting implementation, some features and attributes are required for joining the cross-chain ecosystem. These features are the critical elements for implementing the core interface method for handling block headers or cross-chain transactions. Please note that this chapter is intended for the Header Sync scenario. There is no need to clarify these technical resources for blockchains where Header Sync is not applicable. Requirement List Consensus Algorithm The Consensus Algorithm determines how blockchains select consensus validators, voters, and block producers for minting new blocks and bookkeeping block transactions. The developers need to clearly understand the consensus protocol of the blockchain to get sufficient information for validating block headers. For instance, for blockchains that use POS, one of the essential elements for verifying blocks are signatures from validator nodes, which requires the developers Know the consensus nodes' election process, and who are the consensus nodes in the next epoch. Genesis Block of the Chain The genesis block's block header needs to be submitted to the consortium chain of the cross-chain ecosystem to verify the consequent transactions and block headers on this chain. Block Header Structure and Verification Method The block header verification and processing method and the block structure need to be submitted so that the relay chain can verify the block headers that will be transferred from this chain. The side chain needs to provide its block header format, the serialization, and the deserialization methods. The mode of signature verification allows the relay chain to process and verify block headers. Merkle Tree Structure and Verification Method The Merkle tree structure, the Merkle tree generation, and the verification method for the ledger records or transactions need to be submitted to the relay chain to verify cross-chain transactions from this chain. The source chain stores cross-chain information and construct a Merkle tree, and then sends the Merkle tree root and the Merkle proof of the information to the side chain. The side chain verifies the proof using the Merkle root and confirms the validity of the cross-chain information. Merkle proofs are a solution. When events and transactions are recorded on the blockchain, a corresponding Merkle proof, by having a Merkle proof and the correct block header, we can prove that a particular transaction or event did occur on the chain with certainty. The information relayed by the relayer includes cross-chain transaction proof and the subchain block header (following block header of the cross-chain transaction execution header) containing the state root of transaction proof. The poly chain will first verify the block header. Then the application state root within the block header can help confirm the validity of transaction proof (indicating the cross-chain request is successfully executed on the side chain) and obtain the actual cross-chain transaction message. Copyright © 2021 PolyNetwork all right reserved，powered by GitbookLast modification date： 2021-12-29 14:39:21 "},"add_chain/steps.html":{"url":"add_chain/steps.html","title":"Common Steps for Header Sync","keywords":"","body":"Technical Flow in Header Sync ScenarioOverviewInitializationDeploy Smart ContractNew Chain RegistrationUpdate Registered ChainRegister Core Interface MethodRegister block Sync Method to RelayerRegister Cross Chain Transaction management method to RelayerSync Genesis HeaderSync Target Chain's Genesis Header to PolySync Poly's Genesis Header to Target ChainTechnical Flow in Header Sync Scenario Overview Adding a new chain to poly involves three main parts: Initialization includes smart contract deployment and new chain registration. Register core interface to poly relayer. Sync genesis header involves synchronizing a side chain initial header to poly relay chain and synchronizing poly genesis header to the ccm contract deployed on the side chain. Some of these steps now proceeded only by the poly team following general specifications. For what a developer should do, see Guideline for Developers. Initialization Deploy Smart Contract The core Poly Cross-Chain Smart Contract such as CCM, CCMP, CCD can be found in(Attach a Link to Core smart contract) Poly developers will deploy these contracts with a selected contract account on the side chain. New Chain Registration After the registration process is complete and the Cross Chain Council (formed by poly consensus nodes) approves the application, the chain officially becomes a part of the cross-chain ecosystem. The registration is accomplished using the trusted registered account by the poly team Update Registered Chain When updating side chain information, the registered account needs to send an update application to the relay chain. The updateSideChain method is used to send an application to update the registered information of a particular blockchain Register Core Interface Method Register header sync and cross-chain management function to relayer. So that relayer can call them for every cross-chain event. The core interface method can be found in Guideline for Developers. Register block Sync Method to Relayer Block header synchronization includes two interface methods: SyncGenesisHeader and SyncBlockHeader The former method will only be called once, while the latter is the core method for conducting the cross-chain event and will be called consistently by the relayer. Register Cross Chain Transaction management method to Relayer Register the interface method MakeDepositProposal to relayer. This method is the key for handling cross-chain transactions, and it tells the relayers how to ensure the legitimacy of cross-chain transactions by verifying Merkle proof. Sync Genesis Header Sync Target Chain's Genesis Header to Poly For Initializing side chain, the side chain's initial block header should be synchronized to the poly relay chain so that the consequent block headers of blocks that contain cross-chain events can be verified and synchronized. Sync Poly's Genesis Header to Target Chain Poly chain's initial header should be synchronized to the side chain's CCM contract. The initial block header should include epoch switching information of consensus nodes, from which height the cross-chain transaction from or to Cosmos subchain will be effective. Copyright © 2021 PolyNetwork all right reserved，powered by GitbookLast modification date： 2021-12-28 16:13:05 "},"add_chain/guideline.html":{"url":"add_chain/guideline.html","title":"Develop Guideline for Header Sync","keywords":"","body":"Develop Guideline for Header SyncOverviewBlock Header SynchronizationBlock Header Synchronization Method to be registered to relayerBlock Header Synchronization Entrance MethodCross-Chain ManagementCross Chain ManagementTest ModuleDevelop Guideline for Header Sync Overview This chapter shows the developer how to cooperate with the poly network team to add a chain into the poly cross-chain ecosystem. The functions developers need to implement: Block Header Synchronization Interface Method， including header sync and the entrance functions. Handler for handling the cross-chain transaction with Merkle proof. The poly team will accomplish the remaining actions such as smart contract deployment, side chain registration, and relayer setup. Block Header Synchronization To implement cross-chain features for any chain, say Ethereum, there are two kinds of contracts that need to be deployed- Block header synchronization contract: This contract maintains the record of block headers of the relay chain on this chain. These block headers serve as means to verify cross-chain transactions. The interface methods that need to be implemented by the respective contracts are as follows: Block Header Synchronization Method to be registered to relayer Interface Method Description SyncGenesisHeader Synchronizes the relay chain's genesis block header (or another block header where a change in block generation cycle occurred). The method is called one time only when initializing the side chain. It stores and handles the genesis block header, then fetches the consensus node info of the relay chain; please refer to the code for more details. SyncBlockHeader Consistently synchronizes block cycle change and cross-chain transaction block headers from the relay chain; the relayers use this interface method to synchronize block headers, stores, and process block headers, fetches the consensus node info if block generation cycle changes; please refer to the code for more details. Block Header Synchronization Entrance Method Interface Method Description SyncSideChainGenesisHeader It is the entrance method for synchronizing the genesis block header of the side chain to poly chain and synchronizing the genesis header of the poly chain to ccm contract of the side chain; please refer to the code for more details. The Key information for this method: Service provider(endpoint) Url of side chain Selected genesis block height validators information for verifying genesis headers, it may exist in header information already or need to be fetched from block headers from other block height Other parameters that required for the side chain block header verification Cross-Chain Management Cross-chain management contract: Every chain can have no more than one management contract. It creates cross-chain transactions that are transferred to the relay chain. All the service contracts that contain the business logic need to communicate with the management contract. The interface methods that need to be implemented by the respective contracts are as follows: Cross Chain Management Interface Method Description MakeDepositProposal Creates cross-chain transactions invoked by service contracts. When a cross-chain function is carried out in the logic, a transaction includes a unique chain ID; the transaction is recorded in the Merkle tree. Act as the entrance of verifyFromTx, verifying, storing, and returning MakeTxParam for processing cross-chain steps. Please refer to the code for details verifyFromTx Prepare block header and deserialized proof for verifyMerkleProof, decode the extra data from tx and construct MakeTxParam. Please refer to the code for details verifyMerkleProof Verify the Merkle proof obtained by the relayer generated from the source chain to ensure that all transactions included in this block header have been created and have occurred on the relay chain. Please refer to the code for details Here are the parameters used in methods: MakeDepositProposal: Requires: service *native.NativeService //Native Service that carries values of necessary information of a cross-chain event Returns: type verifyFromTx struct { TxHash []byte CrossChainId []byte //ChainId of source chain FromContractAddress uint64 //Cross Chain Management Contarct address of source chain ToChainId string //ChainId of target chain ToContractAddress uint64 //Cross Chain Management Contarct address of target chain Method []byte //Unlock or lock Args []byte } verifyFromTx: Requires: service *native.NativeService proof []byte //the proof to be serialized and verifyed extra []byte //the transaction information that will be used for contructing verifyFromTx fromChainID uint64, //ChainId of source chain height uint32, //the block height correspoding to current transaction event sideChain *side_chain_manager.SideChain //source chain information that contains ccm contract address Returns: verifyFromTx verifyMerkleProof: Requires: blockData *types.Header //the blockheader corresponding to current transaction event proof []byte //the serilized proof Returns: Val []byte //the proof result for checking extra before constructing verifyFromTx Test Module Implement the function for sending cross-chain transactions to itself using lock proxy. you can see it in Link to test cross-chain code Copyright © 2021 PolyNetwork all right reserved，powered by GitbookLast modification date： 2021-12-29 16:48:33 "},"call_contract/":{"url":"call_contract/","title":"Calling the Cross Chain Smart Contract","keywords":"","body":"Calling the Cross Chain Smart ContractCalling the Cross Chain Smart Contract Business logic serves as smart contract invoked by users both on source chain and target chain. Cross-Chain manager contract offers two interfaces to interact with business logic contract directly. This part introduces how the cross chain interaction processes and how to build your own business logic contract. In additionally, an example of business logic is offered to help understand the interaction more vividly. This Branch is intended for developers who want to develop your own business logic smart contract which interacted with the cross chain manager provided by Poly Network. Here is the outline that will be introduced: Cross Chain Interaction Between Chains Interfaces Offered by Cross Chain Manager Example of Business Logic Smart Contract Copyright © 2021 PolyNetwork all right reserved，powered by GitbookLast modification date： 2021-12-29 14:39:58 "},"call_contract/Interaction.html":{"url":"call_contract/Interaction.html","title":"Cross Chain Interaction Between Chains","keywords":"","body":"Cross Chain Interaction Between ChainsCross Chain Interaction Between Chains The figure above illustrates the cross chain interaction between chain A to chain B. The user sends a cross chain request from chain A by invoking a dApp's cross chain interface, and on the target chain B the dApp's smart contract executes the necessary logic to produce the final result. Chain A and B implement the two contracts and other necessary interfaces, and anyone can develop an infrastructure for dApps around the cross chain management contract. The contracts deployed on chain A and chain B make up a complete cross chain dApp. The complete process flow from chain A to chain B is as follows: The user invokes the service contract on chain A, which then in turn invokes the cross chain management contract. The management contract transfers the parameters to the target chain and a cross chain transaction is created by management contract which is sent to the target chain based on block generation on chain A; Since there is no means of automatic data exchange between two chains, a relayer needs to be set up to transfer block header details from chain A to the relay chain's block header synchronization contract. It also fetches the management contract's response event from chain A which encapsulates the parameters passed by the user, and also fetches the merkle proof. Next, it groups this information together and sends it to the cross chain management contract. The management contract fetches the block headers from chain A, verifies whether or not the cross chain parameters and the proof are valid, and then transmits the necessary information to chain B in the form of an event; Chain B's relayer transfers the relay chain's block headers to chain B's block header synchronization contract. The relevant chain B cross chain transaction parameters and respective merkle proofs are fetched from the ledger records of the relay chain and transmitted to chain B's cross chain management contract; The management contract of chain B determines the legitimacy of the cross chain transaction information and then invokes the relevant target contract and completes the cross chain contract invocation; There are two different merkle proofs that are transferred to the relay chain: The merkle proof that is used to verify the legitimacy of cross chain transactions from chain A The merkle proof that is used to ensure that a transaction has been created and has occurred on the relay chain These merkle proofs help establish a trust mechanism for the cross chain ecosystem. Any chain can join the cross chain ecosystem by setting up the communication interface with the relay chain. Copyright © 2021 PolyNetwork all right reserved，powered by GitbookLast modification date： 2021-12-29 14:39:58 "},"call_contract/Interfaces.html":{"url":"call_contract/Interfaces.html","title":"Interfaces Offered by Cross Chain Manager","keywords":"","body":"Interfaces Offered by Cross Chain ManagerInterfaces Offered by Cross Chain Manager To implement cross chain features for any chain, cross chain management contract is needed to be deployed. Every chain can have no more than one management contract. On source chain, it creates the cross chain transactions that are transferred to the Poly; On target chain, it verifies the legitimacy of transactions and executes the method on target business logic contract. All the business logic smart contract need to communicate with the management contract. Following are the detailed description of three interfaces which interacts with the business logic contracts. /* @param toChainId The target chain id * @param toAddress The address in bytes format to receive same amount of tokens in target chain * @param toContract Target smart contract address in bytes in target block chain * @param txData Transaction data for target chain, include toAssetHash, toAddress, amount * @return true or false */ function crossChain(uint64 toChainId, bytes calldata toContract, bytes calldata method, bytes calldata txData) whenNotPaused external returns (bool) This method creates cross chain transactions, invoked by service contracts when a cross chain function is carried out in the logic contract. This method constructs the rawParam, which contains transaction hash, msg.sender, target chain id, business logic contract to be invoked on target chain, the target method to be invoked and the serialized transaction data which has been already constructed in business logic contract. Then put the hash of rawParam into storage, to help provide proof of transaction existence. /* @param proof Poly chain transaction merkle proof * @param rawHeader The header containing crossStateRoot to verify the above tx merkle proof * @param headerProof The header merkle proof used to verify rawHeader * @param curRawHeader Any header in current epoch consensus of Poly chain * @param headerSig The coverted signature veriable for solidity derived from Poly chain consensus nodes' signature * used to verify the validity of curRawHeader * @return true or false */ function verifyHeaderAndExecuteTx(bytes memory proof, bytes memory rawHeader, bytes memory headerProof, bytes memory curRawHeader, bytes memory headerSig) whenNotPaused public returns (bool) This method is meant to be invoked by relayer, in some cases user could invoke this method by themselves if they get the valid block information from Poly. This method fetches and processes cross chain transactions, finds the merkle root of a transaction based on the block height (in the block header), verifies the legitimacy of transaction using the transaction parameters. After verifying Poly chain header and proof, it will invoke the service contract on the target chain. The detailed invoking will be processed as _executeCrossChainTx method as following. /* @param _toContract The targeting contract that will be invoked by the Ethereum Cross Chain Manager contract * @param _method At which method will be invoked within the targeting contract * @param _args The parameter that will be passed into the targeting contract * @param _fromContractAddr From chain smart contract address * @param _fromChainId Indicate from which chain current cross chain tx comes * @return true or false */ function _executeCrossChainTx(address _toContract, bytes memory _method, bytes memory _args, bytes memory _fromContractAddr, uint64 _fromChainId) internal returns (bool) This method is meant to invoke the targeting contract, and trigger executation of cross chain tx on target chain. Firstly, we need to ensure the targeting contract gonna be invoked is indeed a contract rather than a normal account address. Then we construct a method call on target business logic contract, the first four bytes of the call data for a function call specifies the function to be called. Parameter _method is from the toMerkleValue , which is parsed from proof. And the input parameters format is restricted as (bytes _args, bytes _fromContractAddr, uint64 _fromChainId). These two parts are encodePacked as a call. After calling the method, we need to check that if the return value is true. Only if the return value is true, will the whole cross chain transaction be executed successfully. You may refer to the full code of EthCrossChainManager contract . Copyright © 2021 PolyNetwork all right reserved，powered by GitbookLast modification date： 2021-12-29 16:37:37 "},"call_contract/Example.html":{"url":"call_contract/Example.html","title":"Example of Business Logic Smart Contract","keywords":"","body":"Example of Business Logic Smart ContractLockProxy.solExample of Business Logic Smart Contract This part provides an example of business logic smart contract, which provides a method to cross-chain transfer token between two chains where already equipped with Cross-Chain Manager Contract and other required contracts mentioned above. Here Chain A and B are still represent the source chain and target chain. LockProxy.sol Bind assets: Besides of the verifying the existence of transaction through Cross-Chain Manager (CCM) contract, lock proxy contract needs to make sure of the accuracy of the assets relationship in the transaction. The binded asset mapping relationship which stored in lock proxy contract will help provide the completeness of transaction data. Bind actions also prevent the wrong input from users which may lead to transfer assets to wrong asset contract address. pragma solidity ^0.5.0; import \"./../../libs/ownership/Ownable.sol\"; contract LockProxy is Ownable { address public managerProxyContract; mapping(uint64 => bytes) public proxyHashMap; mapping(address => mapping(uint64 => bytes)) public assetHashMap; // ethCCMProxyAddr: the address of cross chain manager proxy contract on source chain function setManagerProxy(address ethCCMProxyAddr) onlyOwner public { managerProxyContract = ethCCMProxyAddr; emit SetManagerProxyEvent(managerProxyContract); } // toChainId: the target chain id // targetProxyHash: the address of cross chain manager proxy contract on target chain function bindProxyHash(uint64 toChainId, bytes memory targetProxyHash) onlyOwner public returns (bool) { proxyHashMap[toChainId] = targetProxyHash; emit BindProxyEvent(toChainId, targetProxyHash); return true; } // fromAssetHash: asset hash on source chain // toAssetHash: asset hash on target chain function bindAssetHash(address fromAssetHash, uint64 toChainId, bytes memory toAssetHash) onlyOwner public returns (bool) { assetHashMap[fromAssetHash][toChainId] = toAssetHash; emit BindAssetEvent(fromAssetHash, toChainId, toAssetHash, getBalanceFor(fromAssetHash)); return true; } } Since cross-chain transaction processed by CCM Contract, user not only needs to set Cross-Chain Manager Proxy (CCMP) address on source chain, but also needs to bind CCMP contract on target chain to LockProxy contract. Both on Chain A and B, the user needs to bind the asset contract to LockProxy smart contract and the target chain id (here for Chain A, Chain B is the target chain), so that the LockProxy contract can maintain mappings (making connections) from asset contract address on source chain and that on target chain with target chain id. After finishing setting all above, LockProxy contract will work properly as the business logic. Here we go! Cross-Chain transaction: One cross chain transaction can be divided into two parts: on source chain, the lock proxy contract will lock the asset onto contract; on target chain, the lock proxy will unlock the same amount to the target address. The whole process needs to convey the transaction data. The relationships between two chain's transaction data parameters shows below: /* * @param fromAssetHash The asset address in current chain * @param toChainId The target chain id * @param toAddress The address in bytes format to receive same amount of tokens in target chain * @param amount The amount of tokens to be crossed from ethereum to the chain with chainId */ function lock(address fromAssetHash, uint64 toChainId, bytes memory toAddress, uint256 amount) public payable returns (bool) { require(amount != 0, \"amount cannot be zero!\"); require(_transferToContract(fromAssetHash, amount), \"transfer asset from fromAddress to lock_proxy contract failed!\"); bytes memory toAssetHash = assetHashMap[fromAssetHash][toChainId]; require(toAssetHash.length != 0, \"empty illegal toAssetHash\"); TxArgs memory txArgs = TxArgs({ toAssetHash: toAssetHash, toAddress: toAddress, amount: amount }); bytes memory txData = _serializeTxArgs(txArgs); IEthCrossChainManagerProxy eccmp = IEthCrossChainManagerProxy(managerProxyContract); address eccmAddr = eccmp.getEthCrossChainManager(); IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr); bytes memory toProxyHash = proxyHashMap[toChainId]; require(toProxyHash.length != 0, \"empty illegal toProxyHash\"); require(eccm.crossChain(toChainId, toProxyHash, \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\"); emit LockEvent(fromAssetHash, _msgSender(), toChainId, toAssetHash, toAddress, amount); return true; } This function is meant to be invoked by the user, a certain amount tokens will be locked in the proxy contract the invoker/msg.sender immediately. Then the same amount of tokens will be unlocked from target chain proxy contract at the target chain with chainId later; The user makes an asset token cross-chain transaction request through the dApp which works in Chain A, LockProxy smart contract gets the transation information which contains the asset contract address on Chain A the target chain id, the target address on Chain B and amount of token to be transfered. By calling the function lock(), LockProxy contract will lock(transfer) the certain amount to asset contract; Then the transaction data will be packed, which then in turn invokes the cross chain management contract. The management contract transfers the parameters of transaction data to the target chain and a cross chain transaction is created by management contract which is sent to the target chain based on block generation on Chain A; The serialized transaction data, along with the chain id and CCMP contract address of target chain and the method needed to be called on target chain, will be sent through crossChain() in Cross-Chain Manager contract. /* @param argsBs The argument bytes recevied by the lock proxy contract on source chain, * need to be deserialized based on the way of serialization in the source chain proxy contract. * @param fromContractAddr The source chain contract address * @param fromChainId The source chain id */ function unlock(bytes memory argsBs, bytes memory fromContractAddr, uint64 fromChainId) onlyManagerContract public returns (bool) { TxArgs memory args = _deserializeTxArgs(argsBs); require(fromContractAddr.length != 0, \"from proxy contract address cannot be empty\"); require(Utils.equalStorage(proxyHashMap[fromChainId], fromContractAddr), \"From Proxy contract address error!\"); require(args.toAssetHash.length != 0, \"toAssetHash cannot be empty\"); address toAssetHash = Utils.bytesToAddress(args.toAssetHash); require(args.toAddress.length != 0, \"toAddress cannot be empty\"); address toAddress = Utils.bytesToAddress(args.toAddress); require(_transferFromContract(toAssetHash, toAddress, args.amount), \"transfer asset from lock_proxy contract to toAddress failed!\"); emit UnlockEvent(toAssetHash, toAddress, args.amount); return true; } This functions is meant to be invoked by Cross-Chain manager contract. It deserializes the transaction data and invokes the asset contract to release the tokens to target address. After verification through Poly (detailed verification process shown in part Cross Chain Interaction Between Chains), the packed transaction data could be executed on Chain B. verifyHeaderAndExecuteTx() in Cross-Chain Manager contract determines the legitimacy of the cross chain transaction information and resolve the parameters of transaction data from the Poly chain transaction merkle proof and crossStateRoot contained in the block header. Then call the function unlock() to deserialize the transaction data and unlock (transfer) the certain amount of token to the target address on Chain B and completes the cross chain contract invocation. Serialize & deserialize transaction data function _serializeTxArgs(TxArgs memory args) internal pure returns (bytes memory) { bytes memory buff; buff = abi.encodePacked( ZeroCopySink.WriteVarBytes(args.toAssetHash), ZeroCopySink.WriteVarBytes(args.toAddress), ZeroCopySink.WriteUint255(args.amount) ); return buff; } function _deserializeTxArgs(bytes memory valueBs) internal pure returns (TxArgs memory) { TxArgs memory args; uint256 off = 0; (args.toAssetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off); (args.toAddress, off) = ZeroCopySource.NextVarBytes(valueBs, off); (args.amount, off) = ZeroCopySource.NextUint255(valueBs, off); return args; } In the process of contract development, developers will always encounter serialization and deserialization problems, that is, how to save a struct type of data in the database and how to deserialize the byte array read from the database to obtain data of struct type. In the lib, ZeroCopySource.sol and ZeroCopySink.sol offered the interfaces to serialize and deserialize data. When serializing various data types, for fixed-length data (for example: bytes, uint16, uint32, uint64, etc.), directly convert the data into a byte array; for data with variable length, serializing the length is required firstly, and then serialize the data (for example, unsigned integers of unknown size, including uint16, uint32, or uint64, etc.). Deserialization is the opposite of serialization. For all serialization methods, there are corresponding deserialization methods. When reading data of a specified type, if you know its length, you can read it directly; for data with an unknown length, read the length first, and then read the content. You may refer to the full code of LockProxy contract . Copyright © 2021 PolyNetwork all right reserved，powered by GitbookLast modification date： 2021-12-29 16:37:37 "},"FAQ/template.html":{"url":"FAQ/template.html","title":"Integrating New Tokens","keywords":"","body":"Joining the Cross Chain EcosystemOverviewInterface RequirementsBlock Header Synchronization ContractCross Chain Management ContractCross Chain Interaction Between ChainsChain Elements to be Submitted to the Cross Chain EcosystemRegister the Chain on Relay ChainJoining the Cross Chain Ecosystem Overview Poly cross chain ecosystem provides a platform for various different chains to interact and transfer data along with carrying out cross chain transactions. Any chain can freely join the ecosystem. However, the chains that support smart contracts can interact and transfer all kinds of information between chains, while the chains that do not support smart contracts are limited to cross chain asset transfer. There are three factors that determine whether a blockchain can join the Poly cross chain ecosystem: The system implements multiple interfaces either using smart contracts, or as core API that can be used to interact with the chain The chain needs to provide its block header format, the serialization and deserialization methods used, and the mode of signature verification in order to allow the relay chain to be able to process and verify block headers. The chain also needs to provide its merkle tree generation and verification method for the ledger records or transactions. This allows the relay chain to determine the legitimacy of the transaction records. Interface Requirements To implement cross chain features for any chain, say Ethereum, there are two kinds of contracts that need to be deployed- Block header synchronization contract: This contract maintains the record of block headers of the relay chain on this chain. These block headers serve as means to verify cross chain transactions. Cross chain management contract: Every chain can have no more than one management contract. It creates the cross chain transactions that are transferred to the relay chain. All the service contracts that contain the business logic need to communicate with the management contract. The interface methods that need to implemented by the respective contracts are as follows: Block Header Synchronization Contract Interface Method Description SyncGenesisHeader Synchronizes the relay chain's genesis block header (or another block header where a change in block generation cycle occurred), method is invoked one time only when the contract is initialized, stores and processes the genesis block header, fetches the consensus node info of the relay chain, please refer to the code for more details SyncBlockHeader Consistently synchronizes block cycle change and cross chain transaction block headers from the relay chain, relayer uses this interface method to synchronize block headers, stores and processes block headers, fetches the consensus node info if block generation cycle changes, please refer to the code for more details Cross Chain Management Contract Interface Method Description CreateCrossChainTx Creates cross chain transactions, invoked by service contracts when a cross chain function is carried out in the logic, transaction includes unique chain ID, transaction is recorded in the merkle tree, please refer to the code for more details ProcessCrossChainTx Fetches and processes cross chain transactions, invoked by the relayer when fetching transactions and merkle proofs, finds the merkle root of a transaction based on the block height (in the block header), verifies the legitimacy of transaction using the transaction parameters, invokes the service contract on the target chain, please refer to the code for details Cross Chain Interaction Between Chains The figure above illustrates the cross chain interaction between chain A to chain B. The user sends a cross chain request from chain A by invoking a dApp's cross chain interface, and on the target chain B the dApp's smart contract executes the necessary logic to produce the final result. Chain A and B implement the two contracts and other necessary interfaces, and anyone can develop an infrastructure for dApps around the cross chain management contract. The contracts deployed on chain A and chain B make up a complete cross chain dApp. The complete process flow from chain A to chain B is as follows: The user invokes the service contract on chain A, which then in turn invokes the cross chain management contract. The management contract transfers the parameters to the target chain and a cross chain transaction is created by management contract which is sent to the target chain based on block generation on chain A; Since there is no means of automatic data exchange between two chains, a relayer needs to be set up to transfer block header details from chain A to the relay chain's block header synchronization contract. It also fetches the management contract's response event from chain A which encapsulates the parameters passed by the user, and also fetches the merkle proof. Next, it groups this information together and sends it to the cross chain management contract. The management contract fetches the block headers from chain A, verifies whether or not the cross chain parameters and the proof are valid, and then transmits the necessary information to chain B in the form of an event; Chain B's relayer transfers the relay chain's block headers to chain B's block header synchronization contract. The relevant chain B cross chain transaction parameters and respective merkle proofs are fetched from the ledger records of the relay chain and transmitted to chain B's cross chain management contract; The management contract of chain B determines the legitimacy of the cross chain transaction information and then invokes the relevant target contract and completes the cross chain contract invocation; There are two different merkle proofs that are transferred to the relay chain: The merkle proof that is used to verify the legitimacy of cross chain transactions from chain A The merkle proof that is used to ensure that a transaction has been created and has occurred on the relay chain These merkle proofs help establish a trust mechanism for the cross chain ecosystem. Any chain can join the cross chain ecosystem by setting up the communication interface with the relay chain. Chain Elements to be Submitted to the Cross Chain Ecosystem Genesis Block of the Chain The genesis block's block header needs to be submitted to the consortium chain of the cross chain ecosystem so as to allow to it verify the consequent transactions and block headers on this chain. Another high-priority block such as block where the block generation cycle changes can also be submitted in place of the genesis block. Verification and Analysis Method, Block Header Structure The block header verification and processing method along with the block structure needs to be submitted so that the relay chain can verify the block headers that will be transferred from this chain. Merkle Tree Structure and Verification Method The merkle tree structure and the respective verification needs to be submitted to the relay chain such that cross chain transactions from this chain can be verified. Register the Chain on Relay Chain After setting up the necessary cross chain infrastructure, the chain can be registered on the relay chain. The registration API used is as follows: type RegisterSideChainParam struct { Address string ChainId uint64 Router uint64 Name string BlocksToWait uint64 CCMCAddress []byte } Parameter Description Address The wallet address that will be associated to this chain and will be authorized to modify the registration information ChainId Chain ID of this chain Router The routing protocol of the chain, existing routing protocols - 1:BTC, 2:ETH, 3:ONT, isomorphic chains can select existing protocol, rest must first define the respective protocol and then select Name Name of the blockchain network BlocksToWait No. of blocks to wait for in order to confirm finality CCMCAddress Cross Chain Management Contract Address of this chain As the cross chain ecosystem grows with time and more and more chains join in, different routing protocols will become a part of the system and isomorphic chains will directly be able to use the appropriate routing protocol. After the registration process is complete and the Cross Chain Council approves the application, the chain officially becomes a part of the cross chain ecosystem. Copyright © 2021 PolyNetwork all right reserved，powered by GitbookLast modification date： 2021-12-14 15:50:48 "},"GLOSSARY.html":{"url":"GLOSSARY.html","title":"Glossary","keywords":"","body":"RelayerSide ChainSource ChainTarget ChainPoly ChainCanonical BlockRelayer A cross-chain information porter performs some of the most critical operations within the cross-chain. It acts as the medium of interaction between the side chain and the outside world. Each chain in the cross-chain ecosystem has a relayer associated with it. Relayer monitors its corresponding chain network for cross-chain transactions and forwards the respective block headers to the relay chain if detected, gaining available incentives in the process. At the same time, it also monitors for cross-chain transactions taking place on the relay chain and transfers them to the respective side chain. Side Chain A chain that is interested in joining the poly cross-chain ecosystem Source Chain A public chain corresponds to the target chain where a particular asset firstly appears. Target Chain A public chain corresponds to the source chain on which we want to cross an asset and issue a new token. For the ether asset, Ethereum is the source chain. When we want to issue a new OEP4 token in The Ontology network represents the ether, and the Ontology chain will be the target chain for the ether asset. Vice versa, For the ONT token, the Ontology chain is the source chain. When we want to issue a new ERC20 token in the Ethereum chain, Ethereum would be the target chain for the Ont network. Poly Chain The Relay chain in the cross-chain ecosystem. One of the crucial components of the cross-chain ecosystem. Each type of node is deployed and maintained by other individuals or organizations and has its unique governance and trust mechanism. The relay chain is responsible for connecting them, standardizing cross-chain data flow and interfaces, verifying the legitimacy of cross-chain data, etc. Canonical Block A block is included in the primary blockchain and is directly or indirectly referenced by future blocks. Blocks that are not canonical may have been valid but were discarded in favor of the canonical block. Copyright © 2021 PolyNetwork all right reserved，powered by GitbookLast modification date： 2021-12-27 14:40:06 "}}